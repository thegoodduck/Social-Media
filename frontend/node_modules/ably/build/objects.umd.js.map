{
  "version": 3,
  "sources": ["../src/plugins/objects/index.ts", "../src/plugins/objects/objectmessage.ts", "../src/plugins/objects/liveobject.ts", "../src/plugins/objects/objectid.ts", "../src/plugins/objects/livecounter.ts", "../src/plugins/objects/batchcontextlivecounter.ts", "../node_modules/dequal/dist/index.mjs", "../src/plugins/objects/defaults.ts", "../src/plugins/objects/livemap.ts", "../src/plugins/objects/batchcontextlivemap.ts", "../src/plugins/objects/objectspool.ts", "../src/plugins/objects/batchcontext.ts", "../src/plugins/objects/syncobjectsdatapool.ts", "../src/plugins/objects/objects.ts"],
  "sourcesContent": ["import { ObjectMessage } from './objectmessage';\r\nimport { Objects } from './objects';\r\n\r\nexport { Objects, ObjectMessage };\r\n\r\nexport default {\r\n  Objects,\r\n  ObjectMessage,\r\n};\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type { MessageEncoding } from 'common/lib/types/basemessage';\r\nimport type Logger from 'common/lib/util/logger';\r\nimport type * as Utils from 'common/lib/util/utils';\r\nimport type { Bufferlike } from 'common/platform';\r\n\r\nexport type EncodeInitialValueFunction = (\r\n  data: any,\r\n  encoding?: string | null,\r\n) => { data: any; encoding?: string | null };\r\n\r\nexport type EncodeObjectDataFunction = (data: ObjectData) => ObjectData;\r\n\r\nexport enum ObjectOperationAction {\r\n  MAP_CREATE = 0,\r\n  MAP_SET = 1,\r\n  MAP_REMOVE = 2,\r\n  COUNTER_CREATE = 3,\r\n  COUNTER_INC = 4,\r\n  OBJECT_DELETE = 5,\r\n}\r\n\r\nexport enum MapSemantics {\r\n  LWW = 0,\r\n}\r\n\r\n/** An ObjectData represents a value in an object on a channel. */\r\nexport interface ObjectData {\r\n  /** A reference to another object, used to support composable object structures. */\r\n  objectId?: string;\r\n\r\n  /** Can be set by the client to indicate that value in `string` or `bytes` field have an encoding. */\r\n  encoding?: string;\r\n  /** A primitive boolean leaf value in the object graph. Only one value field can be set. */\r\n  boolean?: boolean;\r\n  /** A primitive binary leaf value in the object graph. Only one value field can be set. */\r\n  bytes?: Bufferlike;\r\n  /** A primitive number leaf value in the object graph. Only one value field can be set. */\r\n  number?: number;\r\n  /** A primitive string leaf value in the object graph. Only one value field can be set. */\r\n  string?: string;\r\n}\r\n\r\n/** A MapOp describes an operation to be applied to a Map object. */\r\nexport interface MapOp {\r\n  /** The key of the map entry to which the operation should be applied. */\r\n  key: string;\r\n  /** The data that the map entry should contain if the operation is a MAP_SET operation. */\r\n  data?: ObjectData;\r\n}\r\n\r\n/** A CounterOp describes an operation to be applied to a Counter object. */\r\nexport interface CounterOp {\r\n  /** The data value that should be added to the counter */\r\n  amount: number;\r\n}\r\n\r\n/** A MapEntry represents the value at a given key in a Map object. */\r\nexport interface MapEntry {\r\n  /** Indicates whether the map entry has been removed. */\r\n  tombstone?: boolean;\r\n  /**\r\n   * The {@link ObjectMessage.serial} value of the last operation that was applied to the map entry.\r\n   *\r\n   * It is optional in a MAP_CREATE operation and might be missing, in which case the client should use a nullish value for it\r\n   * and treat it as the \"earliest possible\" serial for comparison purposes.\r\n   */\r\n  timeserial?: string;\r\n  /** The data that represents the value of the map entry. */\r\n  data?: ObjectData;\r\n}\r\n\r\n/** An ObjectMap object represents a map of key-value pairs. */\r\nexport interface ObjectMap {\r\n  /** The conflict-resolution semantics used by the map object. */\r\n  semantics?: MapSemantics;\r\n  // The map entries, indexed by key.\r\n  entries?: Record<string, MapEntry>;\r\n}\r\n\r\n/** An ObjectCounter object represents an incrementable and decrementable value */\r\nexport interface ObjectCounter {\r\n  /** The value of the counter */\r\n  count?: number;\r\n}\r\n\r\n/** An ObjectOperation describes an operation to be applied to an object on a channel. */\r\nexport interface ObjectOperation {\r\n  /** Defines the operation to be applied to the object. */\r\n  action: ObjectOperationAction;\r\n  /** The object ID of the object on a channel to which the operation should be applied. */\r\n  objectId: string;\r\n  /** The payload for the operation if it is an operation on a Map object type. */\r\n  mapOp?: MapOp;\r\n  /** The payload for the operation if it is an operation on a Counter object type. */\r\n  counterOp?: CounterOp;\r\n  /**\r\n   * The payload for the operation if the operation is MAP_CREATE.\r\n   * Defines the initial value for the Map object.\r\n   */\r\n  map?: ObjectMap;\r\n  /**\r\n   * The payload for the operation if the operation is COUNTER_CREATE.\r\n   * Defines the initial value for the Counter object.\r\n   */\r\n  counter?: ObjectCounter;\r\n  /**\r\n   * The nonce, must be present on create operations. This is the random part\r\n   * that has been hashed with the type and initial value to create the object ID.\r\n   */\r\n  nonce?: string;\r\n  /**\r\n   * The initial value bytes for the object. These bytes should be used along with the nonce\r\n   * and timestamp to create the object ID. Frontdoor will use this to verify the object ID.\r\n   * After verification the bytes will be decoded into the Map or Counter objects and\r\n   * the initialValue, nonce, and initialValueEncoding will be removed.\r\n   */\r\n  initialValue?: Bufferlike;\r\n  /** The initial value encoding defines how the initialValue should be interpreted. */\r\n  initialValueEncoding?: Utils.Format;\r\n}\r\n\r\n/** An ObjectState describes the instantaneous state of an object on a channel. */\r\nexport interface ObjectState {\r\n  /** The identifier of the object. */\r\n  objectId: string;\r\n  /** A map of serials keyed by a {@link ObjectMessage.siteCode}, representing the last operations applied to this object */\r\n  siteTimeserials: Record<string, string>;\r\n  /** True if the object has been tombstoned. */\r\n  tombstone: boolean;\r\n  /**\r\n   * The operation that created the object.\r\n   *\r\n   * Can be missing if create operation for the object is not known at this point.\r\n   */\r\n  createOp?: ObjectOperation;\r\n  /**\r\n   * The data that represents the result of applying all operations to a Map object\r\n   * excluding the initial value from the create operation if it is a Map object type.\r\n   */\r\n  map?: ObjectMap;\r\n  /**\r\n   * The data that represents the result of applying all operations to a Counter object\r\n   * excluding the initial value from the create operation if it is a Counter object type.\r\n   */\r\n  counter?: ObjectCounter;\r\n}\r\n\r\n// TODO: tidy up encoding/decoding logic for ObjectMessage:\r\n// Should have separate WireObjectMessage with the correct types received from the server, do the necessary encoding/decoding there.\r\n// For reference, see WireMessage and WirePresenceMessage\r\n/**\r\n * @internal\r\n */\r\nexport class ObjectMessage {\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  extras?: any;\r\n  /**\r\n   * Describes an operation to be applied to an object.\r\n   *\r\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\r\n   */\r\n  operation?: ObjectOperation;\r\n  /**\r\n   * Describes the instantaneous state of an object.\r\n   *\r\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\r\n   */\r\n  object?: ObjectState;\r\n  /** An opaque string that uniquely identifies this object message. */\r\n  serial?: string;\r\n  /** An opaque string used as a key to update the map of serial values on an object. */\r\n  siteCode?: string;\r\n\r\n  constructor(\r\n    private _utils: typeof Utils,\r\n    private _messageEncoding: typeof MessageEncoding,\r\n  ) {}\r\n\r\n  /**\r\n   * Protocol agnostic encoding of the object message's data entries.\r\n   * Mutates the provided ObjectMessage.\r\n   *\r\n   * Uses encoding functions from regular `Message` processing.\r\n   */\r\n  static encode(message: ObjectMessage, client: BaseClient): ObjectMessage {\r\n    const encodeInitialValueFn: EncodeInitialValueFunction = (data, encoding) => {\r\n      const isNativeDataType =\r\n        typeof data == 'string' ||\r\n        typeof data == 'number' ||\r\n        typeof data == 'boolean' ||\r\n        client.Platform.BufferUtils.isBuffer(data) ||\r\n        data === null ||\r\n        data === undefined;\r\n\r\n      const { data: encodedData, encoding: newEncoding } = client.MessageEncoding.encodeData(\r\n        data,\r\n        encoding,\r\n        isNativeDataType,\r\n      );\r\n\r\n      return {\r\n        data: encodedData,\r\n        encoding: newEncoding,\r\n      };\r\n    };\r\n\r\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data) => {\r\n      // TODO: support encoding JSON objects as a JSON string on \"string\" property with an encoding of \"json\"\r\n      // https://ably.atlassian.net/browse/PUB-1667\r\n      // for now just return values as they are\r\n\r\n      return data;\r\n    };\r\n\r\n    message.operation = message.operation\r\n      ? ObjectMessage._encodeObjectOperation(message.operation, encodeObjectDataFn, encodeInitialValueFn)\r\n      : undefined;\r\n    message.object = message.object\r\n      ? ObjectMessage._encodeObjectState(message.object, encodeObjectDataFn, encodeInitialValueFn)\r\n      : undefined;\r\n\r\n    return message;\r\n  }\r\n\r\n  /**\r\n   * Mutates the provided ObjectMessage and decodes all data entries in the message.\r\n   *\r\n   * Format is used to decode the bytes value as it's implicitly encoded depending on the protocol used:\r\n   * - json: bytes are base64 encoded string\r\n   * - msgpack: bytes have a binary representation and don't need to be decoded\r\n   */\r\n  static async decode(\r\n    message: ObjectMessage,\r\n    client: BaseClient,\r\n    logger: Logger,\r\n    LoggerClass: typeof Logger,\r\n    utils: typeof Utils,\r\n    format: Utils.Format | undefined,\r\n  ): Promise<void> {\r\n    // TODO: decide how to handle individual errors from decoding values. currently we throw first ever error we get\r\n\r\n    try {\r\n      if (message.object?.map?.entries) {\r\n        await ObjectMessage._decodeMapEntries(message.object.map.entries, client, format);\r\n      }\r\n\r\n      if (message.object?.createOp?.map?.entries) {\r\n        await ObjectMessage._decodeMapEntries(message.object.createOp.map.entries, client, format);\r\n      }\r\n\r\n      if (message.object?.createOp?.mapOp?.data) {\r\n        await ObjectMessage._decodeObjectData(message.object.createOp.mapOp.data, client, format);\r\n      }\r\n\r\n      if (message.operation?.map?.entries) {\r\n        await ObjectMessage._decodeMapEntries(message.operation.map.entries, client, format);\r\n      }\r\n\r\n      if (message.operation?.mapOp?.data) {\r\n        await ObjectMessage._decodeObjectData(message.operation.mapOp.data, client, format);\r\n      }\r\n    } catch (error) {\r\n      LoggerClass.logAction(logger, LoggerClass.LOG_ERROR, 'ObjectMessage.decode()', utils.inspectError(error));\r\n    }\r\n  }\r\n\r\n  static fromValues(\r\n    values: ObjectMessage | Record<string, unknown>,\r\n    utils: typeof Utils,\r\n    messageEncoding: typeof MessageEncoding,\r\n  ): ObjectMessage {\r\n    return Object.assign(new ObjectMessage(utils, messageEncoding), values);\r\n  }\r\n\r\n  static fromValuesArray(\r\n    values: (ObjectMessage | Record<string, unknown>)[],\r\n    utils: typeof Utils,\r\n    messageEncoding: typeof MessageEncoding,\r\n  ): ObjectMessage[] {\r\n    const count = values.length;\r\n    const result = new Array(count);\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      result[i] = ObjectMessage.fromValues(values[i], utils, messageEncoding);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  static encodeInitialValue(\r\n    initialValue: Partial<ObjectOperation>,\r\n    client: BaseClient,\r\n  ): {\r\n    encodedInitialValue: Bufferlike;\r\n    format: Utils.Format;\r\n  } {\r\n    const format = client.options.useBinaryProtocol ? client.Utils.Format.msgpack : client.Utils.Format.json;\r\n\r\n    // initial value object may contain user provided data that requires an additional encoding (for example buffers as map keys).\r\n    // so we need to encode that data first as if we were sending it over the wire. we can use an ObjectMessage methods for this\r\n    const msg = ObjectMessage.fromValues({ operation: initialValue }, client.Utils, client.MessageEncoding);\r\n    ObjectMessage.encode(msg, client);\r\n    const { operation: initialValueWithDataEncoding } = ObjectMessage._encodeForWireProtocol(\r\n      msg,\r\n      client.MessageEncoding,\r\n      format,\r\n    );\r\n\r\n    // initial value field should be represented as an array of bytes over the wire. so we encode the whole object based on the client encoding format\r\n    const encodedInitialValue = client.Utils.encodeBody(initialValueWithDataEncoding, client._MsgPack, format);\r\n\r\n    // if we've got string result (for example, json encoding was used), we need to additionally convert it to bytes array with utf8 encoding\r\n    if (typeof encodedInitialValue === 'string') {\r\n      return {\r\n        encodedInitialValue: client.Platform.BufferUtils.utf8Encode(encodedInitialValue),\r\n        format,\r\n      };\r\n    }\r\n\r\n    return {\r\n      encodedInitialValue,\r\n      format,\r\n    };\r\n  }\r\n\r\n  private static async _decodeMapEntries(\r\n    mapEntries: Record<string, MapEntry>,\r\n    client: BaseClient,\r\n    format: Utils.Format | undefined,\r\n  ): Promise<void> {\r\n    for (const entry of Object.values(mapEntries)) {\r\n      if (entry.data) {\r\n        await ObjectMessage._decodeObjectData(entry.data, client, format);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static async _decodeObjectData(\r\n    objectData: ObjectData,\r\n    client: BaseClient,\r\n    format: Utils.Format | undefined,\r\n  ): Promise<void> {\r\n    // TODO: support decoding JSON objects stored as a JSON string with an encoding of \"json\"\r\n    // https://ably.atlassian.net/browse/PUB-1667\r\n    // currently we check only the \"bytes\" field:\r\n    // - if connection is msgpack - \"bytes\" was received as msgpack encoded bytes, no need to decode, it's already a buffer\r\n    // - if connection is json - \"bytes\" was received as a base64 string, need to decode it to a buffer\r\n\r\n    if (format !== 'msgpack' && objectData.bytes != null) {\r\n      // connection is using JSON protocol, decode bytes value\r\n      objectData.bytes = client.Platform.BufferUtils.base64Decode(String(objectData.bytes));\r\n    }\r\n  }\r\n\r\n  private static _encodeObjectOperation(\r\n    objectOperation: ObjectOperation,\r\n    encodeObjectDataFn: EncodeObjectDataFunction,\r\n    encodeInitialValueFn: EncodeInitialValueFunction,\r\n  ): ObjectOperation {\r\n    // deep copy \"objectOperation\" object so we can modify the copy here.\r\n    // buffer values won't be correctly copied, so we will need to set them again explicitly.\r\n    const objectOperationCopy = JSON.parse(JSON.stringify(objectOperation)) as ObjectOperation;\r\n\r\n    if (objectOperationCopy.mapOp?.data) {\r\n      // use original \"objectOperation\" object when encoding values, so we have access to the original buffer values.\r\n      objectOperationCopy.mapOp.data = ObjectMessage._encodeObjectData(\r\n        objectOperation.mapOp?.data!,\r\n        encodeObjectDataFn,\r\n      );\r\n    }\r\n\r\n    if (objectOperationCopy.map?.entries) {\r\n      Object.entries(objectOperationCopy.map.entries).forEach(([key, entry]) => {\r\n        if (entry.data) {\r\n          // use original \"objectOperation\" object when encoding values, so we have access to original buffer values.\r\n          entry.data = ObjectMessage._encodeObjectData(objectOperation?.map?.entries?.[key].data!, encodeObjectDataFn);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (objectOperation.initialValue) {\r\n      // use original \"objectOperation\" object so we have access to the original buffer value\r\n      const { data: encodedInitialValue } = encodeInitialValueFn(objectOperation.initialValue);\r\n      objectOperationCopy.initialValue = encodedInitialValue;\r\n    }\r\n\r\n    return objectOperationCopy;\r\n  }\r\n\r\n  private static _encodeObjectState(\r\n    objectState: ObjectState,\r\n    encodeObjectDataFn: EncodeObjectDataFunction,\r\n    encodeInitialValueFn: EncodeInitialValueFunction,\r\n  ): ObjectState {\r\n    // deep copy \"objectState\" object so we can modify the copy here.\r\n    // buffer values won't be correctly copied, so we will need to set them again explicitly.\r\n    const objectStateCopy = JSON.parse(JSON.stringify(objectState)) as ObjectState;\r\n\r\n    if (objectStateCopy.map?.entries) {\r\n      Object.entries(objectStateCopy.map.entries).forEach(([key, entry]) => {\r\n        if (entry.data) {\r\n          // use original \"objectState\" object when encoding values, so we have access to original buffer values.\r\n          entry.data = ObjectMessage._encodeObjectData(objectState?.map?.entries?.[key].data!, encodeObjectDataFn);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (objectStateCopy.createOp) {\r\n      // use original \"objectState\" object when encoding values, so we have access to original buffer values.\r\n      objectStateCopy.createOp = ObjectMessage._encodeObjectOperation(\r\n        objectState.createOp!,\r\n        encodeObjectDataFn,\r\n        encodeInitialValueFn,\r\n      );\r\n    }\r\n\r\n    return objectStateCopy;\r\n  }\r\n\r\n  private static _encodeObjectData(data: ObjectData, encodeFn: EncodeObjectDataFunction): ObjectData {\r\n    const encodedData = encodeFn(data);\r\n    return encodedData;\r\n  }\r\n\r\n  /**\r\n   * Encodes operation and object fields of the ObjectMessage. Does not mutate the provided ObjectMessage.\r\n   *\r\n   * Uses encoding functions from regular `Message` processing.\r\n   */\r\n  private static _encodeForWireProtocol(\r\n    message: ObjectMessage,\r\n    messageEncoding: typeof MessageEncoding,\r\n    format: Utils.Format,\r\n  ): {\r\n    operation?: ObjectOperation;\r\n    objectState?: ObjectState;\r\n  } {\r\n    const encodeInitialValueFn: EncodeInitialValueFunction = (data, encoding) => {\r\n      const { data: encodedData, encoding: newEncoding } = messageEncoding.encodeDataForWire(data, encoding, format);\r\n      return {\r\n        data: encodedData,\r\n        encoding: newEncoding,\r\n      };\r\n    };\r\n\r\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data) => {\r\n      // TODO: support encoding JSON objects as a JSON string on \"string\" property with an encoding of \"json\"\r\n      // https://ably.atlassian.net/browse/PUB-1667\r\n      // currently we check only the \"bytes\" field:\r\n      // - if connection is msgpack - \"bytes\" will will be sent as msgpack bytes, no need to encode here\r\n      // - if connection is json - \"bytes\" will be encoded as a base64 string\r\n\r\n      let encodedBytes: any = data.bytes;\r\n      if (data.bytes != null) {\r\n        const result = messageEncoding.encodeDataForWire(data.bytes, data.encoding, format);\r\n        encodedBytes = result.data;\r\n        // no need to change the encoding\r\n      }\r\n\r\n      return {\r\n        ...data,\r\n        bytes: encodedBytes,\r\n      };\r\n    };\r\n\r\n    const encodedOperation = message.operation\r\n      ? ObjectMessage._encodeObjectOperation(message.operation, encodeObjectDataFn, encodeInitialValueFn)\r\n      : undefined;\r\n    const encodedObjectState = message.object\r\n      ? ObjectMessage._encodeObjectState(message.object, encodeObjectDataFn, encodeInitialValueFn)\r\n      : undefined;\r\n\r\n    return {\r\n      operation: encodedOperation,\r\n      objectState: encodedObjectState,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify().\r\n   *\r\n   * This will prepare the message to be transmitted over the wire to Ably.\r\n   * It will encode the data payload according to the wire protocol used on the client.\r\n   * It will transform any client-side enum string representations into their corresponding numbers, if needed (like \"action\" fields).\r\n   */\r\n  toJSON(): {\r\n    id?: string;\r\n    clientId?: string;\r\n    operation?: ObjectOperation;\r\n    object?: ObjectState;\r\n    extras?: any;\r\n  } {\r\n    // we can infer the format used by client by inspecting with what arguments this method was called.\r\n    // if JSON protocol is being used, the JSON.stringify() will be called and this toJSON() method will have a non-empty arguments list.\r\n    // MSGPack protocol implementation also calls toJSON(), but with an empty arguments list.\r\n    const format = arguments.length > 0 ? this._utils.Format.json : this._utils.Format.msgpack;\r\n    const { operation, objectState } = ObjectMessage._encodeForWireProtocol(this, this._messageEncoding, format);\r\n\r\n    return {\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      operation,\r\n      object: objectState,\r\n      extras: this.extras,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[ObjectMessage';\r\n\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    // TODO: prettify output for operation and object and encode buffers.\r\n    // see examples for data in Message and PresenceMessage\r\n    if (this.operation) result += '; operation=' + JSON.stringify(this.operation);\r\n    if (this.object) result += '; object=' + JSON.stringify(this.object);\r\n    if (this.extras) result += '; extras=' + JSON.stringify(this.extras);\r\n    if (this.serial) result += '; serial=' + this.serial;\r\n    if (this.siteCode) result += '; siteCode=' + this.siteCode;\r\n\r\n    result += ']';\r\n\r\n    return result;\r\n  }\r\n\r\n  getMessageSize(): number {\r\n    let size = 0;\r\n\r\n    size += this.clientId?.length ?? 0;\r\n    if (this.operation) {\r\n      size += this._getObjectOperationSize(this.operation);\r\n    }\r\n    if (this.object) {\r\n      size += this._getObjectStateSize(this.object);\r\n    }\r\n    if (this.extras) {\r\n      size += JSON.stringify(this.extras).length;\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  private _getObjectOperationSize(operation: ObjectOperation): number {\r\n    let size = 0;\r\n\r\n    if (operation.mapOp) {\r\n      size += this._getMapOpSize(operation.mapOp);\r\n    }\r\n    if (operation.counterOp) {\r\n      size += this._getCounterOpSize(operation.counterOp);\r\n    }\r\n    if (operation.map) {\r\n      size += this._getObjectMapSize(operation.map);\r\n    }\r\n    if (operation.counter) {\r\n      size += this._getObjectCounterSize(operation.counter);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  private _getObjectStateSize(obj: ObjectState): number {\r\n    let size = 0;\r\n\r\n    if (obj.map) {\r\n      size += this._getObjectMapSize(obj.map);\r\n    }\r\n    if (obj.counter) {\r\n      size += this._getObjectCounterSize(obj.counter);\r\n    }\r\n    if (obj.createOp) {\r\n      size += this._getObjectOperationSize(obj.createOp);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  private _getObjectMapSize(map: ObjectMap): number {\r\n    let size = 0;\r\n\r\n    Object.entries(map.entries ?? {}).forEach(([key, entry]) => {\r\n      size += key?.length ?? 0;\r\n      if (entry) {\r\n        size += this._getMapEntrySize(entry);\r\n      }\r\n    });\r\n\r\n    return size;\r\n  }\r\n\r\n  private _getObjectCounterSize(counter: ObjectCounter): number {\r\n    if (counter.count == null) {\r\n      return 0;\r\n    }\r\n\r\n    return 8;\r\n  }\r\n\r\n  private _getMapEntrySize(entry: MapEntry): number {\r\n    let size = 0;\r\n\r\n    if (entry.data) {\r\n      size += this._getObjectDataSize(entry.data);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  private _getMapOpSize(mapOp: MapOp): number {\r\n    let size = 0;\r\n\r\n    size += mapOp.key?.length ?? 0;\r\n\r\n    if (mapOp.data) {\r\n      size += this._getObjectDataSize(mapOp.data);\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  private _getCounterOpSize(operation: CounterOp): number {\r\n    if (operation.amount == null) {\r\n      return 0;\r\n    }\r\n\r\n    return 8;\r\n  }\r\n\r\n  private _getObjectDataSize(data: ObjectData): number {\r\n    let size = 0;\r\n\r\n    if (data.boolean != null) {\r\n      size += this._utils.dataSizeBytes(data.boolean);\r\n    }\r\n    if (data.bytes != null) {\r\n      size += this._utils.dataSizeBytes(data.bytes);\r\n    }\r\n    if (data.number != null) {\r\n      size += this._utils.dataSizeBytes(data.number);\r\n    }\r\n    if (data.string != null) {\r\n      size += this._utils.dataSizeBytes(data.string);\r\n    }\r\n\r\n    return size;\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type EventEmitter from 'common/lib/util/eventemitter';\r\nimport { ObjectMessage, ObjectOperation, ObjectState } from './objectmessage';\r\nimport { Objects } from './objects';\r\n\r\nexport enum LiveObjectSubscriptionEvent {\r\n  updated = 'updated',\r\n}\r\n\r\nexport interface LiveObjectData {\r\n  data: any;\r\n}\r\n\r\nexport interface LiveObjectUpdate {\r\n  update: any;\r\n}\r\n\r\nexport interface LiveObjectUpdateNoop {\r\n  // have optional update field with undefined type so it's not possible to create a noop object with a meaningful update property.\r\n  update?: undefined;\r\n  noop: true;\r\n}\r\n\r\nexport interface SubscribeResponse {\r\n  unsubscribe(): void;\r\n}\r\n\r\nexport enum LiveObjectLifecycleEvent {\r\n  deleted = 'deleted',\r\n}\r\n\r\nexport type LiveObjectLifecycleEventCallback = () => void;\r\n\r\nexport interface OnLiveObjectLifecycleEventResponse {\r\n  off(): void;\r\n}\r\n\r\nexport abstract class LiveObject<\r\n  TData extends LiveObjectData = LiveObjectData,\r\n  TUpdate extends LiveObjectUpdate = LiveObjectUpdate,\r\n> {\r\n  protected _client: BaseClient;\r\n  protected _subscriptions: EventEmitter;\r\n  protected _lifecycleEvents: EventEmitter;\r\n  protected _objectId: string;\r\n  /**\r\n   * Represents an aggregated value for an object, which combines the initial value for an object from the create operation,\r\n   * and all object operations applied to the object.\r\n   */\r\n  protected _dataRef: TData;\r\n  protected _siteTimeserials: Record<string, string>;\r\n  protected _createOperationIsMerged: boolean;\r\n  private _tombstone: boolean;\r\n  /**\r\n   * Even though the {@link ObjectMessage.serial} value from the operation that deleted the object contains the timestamp value,\r\n   * the serial should be treated as an opaque string on the client, meaning we should not attempt to parse it.\r\n   *\r\n   * Therefore, we need to set our own timestamp using local clock when the object is deleted client-side.\r\n   * Strictly speaking, this does make an assumption about the client clock not being too heavily skewed behind the server,\r\n   * but it is an acceptable compromise for the time being, as the likelihood of encountering a race here is pretty low given the grace periods we use.\r\n   */\r\n  private _tombstonedAt: number | undefined;\r\n\r\n  protected constructor(\r\n    protected _objects: Objects,\r\n    objectId: string,\r\n  ) {\r\n    this._client = this._objects.getClient();\r\n    this._subscriptions = new this._client.EventEmitter(this._client.logger);\r\n    this._lifecycleEvents = new this._client.EventEmitter(this._client.logger);\r\n    this._objectId = objectId;\r\n    this._dataRef = this._getZeroValueData();\r\n    // use empty map of serials by default, so any future operation can be applied to this object\r\n    this._siteTimeserials = {};\r\n    this._createOperationIsMerged = false;\r\n    this._tombstone = false;\r\n  }\r\n\r\n  subscribe(listener: (update: TUpdate) => void): SubscribeResponse {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n\r\n    this._subscriptions.on(LiveObjectSubscriptionEvent.updated, listener);\r\n\r\n    const unsubscribe = () => {\r\n      this._subscriptions.off(LiveObjectSubscriptionEvent.updated, listener);\r\n    };\r\n\r\n    return { unsubscribe };\r\n  }\r\n\r\n  unsubscribe(listener: (update: TUpdate) => void): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n\r\n    // current implementation of the EventEmitter will remove all listeners if .off is called without arguments or with nullish arguments.\r\n    // or when called with just an event argument, it will remove all listeners for the event.\r\n    // thus we need to check that listener does actually exist before calling .off.\r\n    if (this._client.Utils.isNil(listener)) {\r\n      return;\r\n    }\r\n\r\n    this._subscriptions.off(LiveObjectSubscriptionEvent.updated, listener);\r\n  }\r\n\r\n  unsubscribeAll(): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n    this._subscriptions.off(LiveObjectSubscriptionEvent.updated);\r\n  }\r\n\r\n  on(event: LiveObjectLifecycleEvent, callback: LiveObjectLifecycleEventCallback): OnLiveObjectLifecycleEventResponse {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n    this._lifecycleEvents.on(event, callback);\r\n\r\n    const off = () => {\r\n      this._lifecycleEvents.off(event, callback);\r\n    };\r\n\r\n    return { off };\r\n  }\r\n\r\n  off(event: LiveObjectLifecycleEvent, callback: LiveObjectLifecycleEventCallback): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n\r\n    // prevent accidentally calling .off without any arguments on an EventEmitter and removing all callbacks\r\n    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {\r\n      return;\r\n    }\r\n\r\n    this._lifecycleEvents.off(event, callback);\r\n  }\r\n\r\n  offAll(): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n    this._lifecycleEvents.off();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getObjectId(): string {\r\n    return this._objectId;\r\n  }\r\n\r\n  /**\r\n   * Emits the {@link LiveObjectSubscriptionEvent.updated} event with provided update object if it isn't a noop.\r\n   *\r\n   * @internal\r\n   */\r\n  notifyUpdated(update: TUpdate | LiveObjectUpdateNoop): void {\r\n    // should not emit update event if update was noop\r\n    if ((update as LiveObjectUpdateNoop).noop) {\r\n      return;\r\n    }\r\n\r\n    this._subscriptions.emit(LiveObjectSubscriptionEvent.updated, update);\r\n  }\r\n\r\n  /**\r\n   * Clears the object's data, cancels any buffered operations and sets the tombstone flag to `true`.\r\n   *\r\n   * @internal\r\n   */\r\n  tombstone(): TUpdate {\r\n    this._tombstone = true;\r\n    this._tombstonedAt = Date.now();\r\n    const update = this.clearData();\r\n    this._lifecycleEvents.emit(LiveObjectLifecycleEvent.deleted);\r\n\r\n    return update;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  isTombstoned(): boolean {\r\n    return this._tombstone;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  tombstonedAt(): number | undefined {\r\n    return this._tombstonedAt;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  clearData(): TUpdate {\r\n    const previousDataRef = this._dataRef;\r\n    this._dataRef = this._getZeroValueData();\r\n    return this._updateFromDataDiff(previousDataRef, this._dataRef);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the given serial indicates that the operation to which it belongs should be applied to the object.\r\n   *\r\n   * An operation should be applied if its serial is strictly greater than the serial in the `siteTimeserials` map for the same site.\r\n   * If `siteTimeserials` map does not contain a serial for the same site, the operation should be applied.\r\n   */\r\n  protected _canApplyOperation(opSerial: string | undefined, opSiteCode: string | undefined): boolean {\r\n    if (!opSerial) {\r\n      throw new this._client.ErrorInfo(`Invalid serial: ${opSerial}`, 92000, 500);\r\n    }\r\n\r\n    if (!opSiteCode) {\r\n      throw new this._client.ErrorInfo(`Invalid site code: ${opSiteCode}`, 92000, 500);\r\n    }\r\n\r\n    const siteSerial = this._siteTimeserials[opSiteCode];\r\n    return !siteSerial || opSerial > siteSerial;\r\n  }\r\n\r\n  protected _applyObjectDelete(): TUpdate {\r\n    return this.tombstone();\r\n  }\r\n\r\n  /**\r\n   * Apply object operation message on this LiveObject.\r\n   *\r\n   * @internal\r\n   */\r\n  abstract applyOperation(op: ObjectOperation, msg: ObjectMessage): void;\r\n  /**\r\n   * Overrides internal data for this LiveObject with data from the given object state.\r\n   * Provided object state should hold a valid data for current LiveObject, e.g. counter data for LiveCounter, map data for LiveMap.\r\n   *\r\n   * Object states are received during sync sequence, and sync sequence is a source of truth for the current state of the objects,\r\n   * so we can use the data received from the sync sequence directly and override any data values or site serials this LiveObject has\r\n   * without the need to merge them.\r\n   *\r\n   * Returns an update object that describes the changes applied based on the object's previous value.\r\n   *\r\n   * @internal\r\n   */\r\n  abstract overrideWithObjectState(objectState: ObjectState): TUpdate | LiveObjectUpdateNoop;\r\n  /**\r\n   * @internal\r\n   */\r\n  abstract onGCInterval(): void;\r\n\r\n  protected abstract _getZeroValueData(): TData;\r\n  /**\r\n   * Calculate the update object based on the current LiveObject data and incoming new data.\r\n   */\r\n  protected abstract _updateFromDataDiff(prevDataRef: TData, newDataRef: TData): TUpdate;\r\n  /**\r\n   * Merges the initial data from the create operation into the LiveObject.\r\n   *\r\n   * Client SDKs do not need to keep around the object operation that created the object,\r\n   * so we can merge the initial data the first time we receive it for the object,\r\n   * and work with aggregated value after that.\r\n   *\r\n   * This saves us from needing to merge the initial value with operations applied to\r\n   * the object every time the object is read.\r\n   */\r\n  protected abstract _mergeInitialDataFromCreateOperation(objectOperation: ObjectOperation): TUpdate;\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type Platform from 'common/platform';\r\nimport type { Bufferlike } from 'common/platform';\r\n\r\nexport type LiveObjectType = 'map' | 'counter';\r\n\r\n/**\r\n * Represents a parsed object id.\r\n *\r\n * @internal\r\n */\r\nexport class ObjectId {\r\n  private constructor(\r\n    readonly type: LiveObjectType,\r\n    readonly hash: string,\r\n    readonly msTimestamp: number,\r\n  ) {}\r\n\r\n  static fromInitialValue(\r\n    platform: typeof Platform,\r\n    objectType: LiveObjectType,\r\n    encodedInitialValue: Bufferlike,\r\n    nonce: string,\r\n    msTimestamp: number,\r\n  ): ObjectId {\r\n    const valueForHashBuffer = platform.BufferUtils.concat([\r\n      encodedInitialValue,\r\n      platform.BufferUtils.utf8Encode(':'),\r\n      platform.BufferUtils.utf8Encode(nonce),\r\n    ]);\r\n    const hashBuffer = platform.BufferUtils.sha256(valueForHashBuffer);\r\n    const hash = platform.BufferUtils.base64UrlEncode(hashBuffer);\r\n\r\n    return new ObjectId(objectType, hash, msTimestamp);\r\n  }\r\n\r\n  /**\r\n   * Create ObjectId instance from hashed object id string.\r\n   */\r\n  static fromString(client: BaseClient, objectId: string | null | undefined): ObjectId {\r\n    if (client.Utils.isNil(objectId)) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    const [type, rest] = objectId.split(':');\r\n    if (!type || !rest) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    if (!['map', 'counter'].includes(type)) {\r\n      throw new client.ErrorInfo(`Invalid object type in object id: ${objectId}`, 92000, 500);\r\n    }\r\n\r\n    const [hash, msTimestamp] = rest.split('@');\r\n    if (!hash || !msTimestamp) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    if (!Number.isInteger(Number.parseInt(msTimestamp))) {\r\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\r\n    }\r\n\r\n    return new ObjectId(type as LiveObjectType, hash, Number.parseInt(msTimestamp));\r\n  }\r\n\r\n  toString(): string {\r\n    return `${this.type}:${this.hash}@${this.msTimestamp}`;\r\n  }\r\n}\r\n", "import { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\r\nimport { ObjectId } from './objectid';\r\nimport { CounterOp, ObjectMessage, ObjectOperation, ObjectOperationAction, ObjectState } from './objectmessage';\r\nimport { Objects } from './objects';\r\n\r\nexport interface LiveCounterData extends LiveObjectData {\r\n  data: number;\r\n}\r\n\r\nexport interface LiveCounterUpdate extends LiveObjectUpdate {\r\n  update: { amount: number };\r\n}\r\n\r\nexport class LiveCounter extends LiveObject<LiveCounterData, LiveCounterUpdate> {\r\n  /**\r\n   * Returns a {@link LiveCounter} instance with a 0 value.\r\n   *\r\n   * @internal\r\n   */\r\n  static zeroValue(objects: Objects, objectId: string): LiveCounter {\r\n    return new LiveCounter(objects, objectId);\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveCounter} instance based on the provided object state.\r\n   * The provided object state must hold a valid counter object data.\r\n   *\r\n   * @internal\r\n   */\r\n  static fromObjectState(objects: Objects, objectState: ObjectState): LiveCounter {\r\n    const obj = new LiveCounter(objects, objectState.objectId);\r\n    obj.overrideWithObjectState(objectState);\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveCounter} instance based on the provided COUNTER_CREATE object operation.\r\n   * The provided object operation must hold a valid counter object data.\r\n   *\r\n   * @internal\r\n   */\r\n  static fromObjectOperation(objects: Objects, objectOperation: ObjectOperation): LiveCounter {\r\n    const obj = new LiveCounter(objects, objectOperation.objectId);\r\n    obj._mergeInitialDataFromCreateOperation(objectOperation);\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createCounterIncMessage(objects: Objects, objectId: string, amount: number): ObjectMessage {\r\n    const client = objects.getClient();\r\n\r\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\r\n      throw new client.ErrorInfo('Counter value increment should be a valid number', 40003, 400);\r\n    }\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          action: ObjectOperationAction.COUNTER_INC,\r\n          objectId,\r\n          counterOp: { amount },\r\n        } as ObjectOperation,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static async createCounterCreateMessage(objects: Objects, count?: number): Promise<ObjectMessage> {\r\n    const client = objects.getClient();\r\n\r\n    if (count !== undefined && (typeof count !== 'number' || !Number.isFinite(count))) {\r\n      throw new client.ErrorInfo('Counter value should be a valid number', 40003, 400);\r\n    }\r\n\r\n    const initialValueObj = LiveCounter.createInitialValueObject(count);\r\n    const { encodedInitialValue, format } = ObjectMessage.encodeInitialValue(initialValueObj, client);\r\n    const nonce = client.Utils.cheapRandStr();\r\n    const msTimestamp = await client.getTimestamp(true);\r\n\r\n    const objectId = ObjectId.fromInitialValue(\r\n      client.Platform,\r\n      'counter',\r\n      encodedInitialValue,\r\n      nonce,\r\n      msTimestamp,\r\n    ).toString();\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          ...initialValueObj,\r\n          action: ObjectOperationAction.COUNTER_CREATE,\r\n          objectId,\r\n          nonce,\r\n          initialValue: encodedInitialValue,\r\n          initialValueEncoding: format,\r\n        } as ObjectOperation,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createInitialValueObject(count?: number): Pick<ObjectOperation, 'counter'> {\r\n    return {\r\n      counter: {\r\n        count: count ?? 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  value(): number {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    return this._dataRef.data;\r\n  }\r\n\r\n  /**\r\n   * Send a COUNTER_INC operation to the realtime system to increment a value on this LiveCounter object.\r\n   *\r\n   * This does not modify the underlying data of this LiveCounter object. Instead, the change will be applied when\r\n   * the published COUNTER_INC operation is echoed back to the client and applied to the object following the regular\r\n   * operation application procedure.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\r\n   */\r\n  async increment(amount: number): Promise<void> {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    const msg = LiveCounter.createCounterIncMessage(this._objects, this.getObjectId(), amount);\r\n    return this._objects.publish([msg]);\r\n  }\r\n\r\n  /**\r\n   * An alias for calling {@link LiveCounter.increment | LiveCounter.increment(-amount)}\r\n   */\r\n  async decrement(amount: number): Promise<void> {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    // do an explicit type safety check here before negating the amount value,\r\n    // so we don't unintentionally change the type sent by a user\r\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\r\n      throw new this._client.ErrorInfo('Counter value decrement should be a valid number', 40003, 400);\r\n    }\r\n\r\n    return this.increment(-amount);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  applyOperation(op: ObjectOperation, msg: ObjectMessage): void {\r\n    if (op.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    const opSerial = msg.serial!;\r\n    const opSiteCode = msg.siteCode!;\r\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveCounter.applyOperation()',\r\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return;\r\n    }\r\n    // should update stored site serial immediately. doesn't matter if we successfully apply the op,\r\n    // as it's important to mark that the op was processed by the object\r\n    this._siteTimeserials[opSiteCode] = opSerial;\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned so the operation cannot be applied\r\n      return;\r\n    }\r\n\r\n    let update: LiveCounterUpdate | LiveObjectUpdateNoop;\r\n    switch (op.action) {\r\n      case ObjectOperationAction.COUNTER_CREATE:\r\n        update = this._applyCounterCreate(op);\r\n        break;\r\n\r\n      case ObjectOperationAction.COUNTER_INC:\r\n        if (this._client.Utils.isNil(op.counterOp)) {\r\n          this._throwNoPayloadError(op);\r\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\r\n          return;\r\n        } else {\r\n          update = this._applyCounterInc(op.counterOp);\r\n        }\r\n        break;\r\n\r\n      case ObjectOperationAction.OBJECT_DELETE:\r\n        update = this._applyObjectDelete();\r\n        break;\r\n\r\n      default:\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n    }\r\n\r\n    this.notifyUpdated(update);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  overrideWithObjectState(objectState: ObjectState): LiveCounterUpdate | LiveObjectUpdateNoop {\r\n    if (objectState.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveCounter objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    if (!this._client.Utils.isNil(objectState.createOp)) {\r\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\r\n      if (objectState.createOp.objectId !== this.getObjectId()) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveCounter objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n\r\n      if (objectState.createOp.action !== ObjectOperationAction.COUNTER_CREATE) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveCounter objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n    }\r\n\r\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the operation.\r\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\r\n    this._siteTimeserials = objectState.siteTimeserials ?? {};\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\r\n      return { noop: true };\r\n    }\r\n\r\n    const previousDataRef = this._dataRef;\r\n    if (objectState.tombstone) {\r\n      // tombstone this object and ignore the data from the object state message\r\n      this.tombstone();\r\n    } else {\r\n      // override data for this object with data from the object state\r\n      this._createOperationIsMerged = false;\r\n      this._dataRef = { data: objectState.counter?.count ?? 0 };\r\n      if (!this._client.Utils.isNil(objectState.createOp)) {\r\n        this._mergeInitialDataFromCreateOperation(objectState.createOp);\r\n      }\r\n    }\r\n\r\n    // if object got tombstoned, the update object will include all data that got cleared.\r\n    // otherwise it is a diff between previous value and new value from object state.\r\n    return this._updateFromDataDiff(previousDataRef, this._dataRef);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  onGCInterval(): void {\r\n    // nothing to GC for a counter object\r\n    return;\r\n  }\r\n\r\n  protected _getZeroValueData(): LiveCounterData {\r\n    return { data: 0 };\r\n  }\r\n\r\n  protected _updateFromDataDiff(prevDataRef: LiveCounterData, newDataRef: LiveCounterData): LiveCounterUpdate {\r\n    const counterDiff = newDataRef.data - prevDataRef.data;\r\n    return { update: { amount: counterDiff } };\r\n  }\r\n\r\n  protected _mergeInitialDataFromCreateOperation(objectOperation: ObjectOperation): LiveCounterUpdate {\r\n    // if a counter object is missing for the COUNTER_CREATE op, the initial value is implicitly 0 in this case.\r\n    // note that it is intentional to SUM the incoming count from the create op.\r\n    // if we got here, it means that current counter instance is missing the initial value in its data reference,\r\n    // which we're going to add now.\r\n    this._dataRef.data += objectOperation.counter?.count ?? 0;\r\n    this._createOperationIsMerged = true;\r\n\r\n    return { update: { amount: objectOperation.counter?.count ?? 0 } };\r\n  }\r\n\r\n  private _throwNoPayloadError(op: ObjectOperation): void {\r\n    throw new this._client.ErrorInfo(\r\n      `No payload found for ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\r\n      92000,\r\n      500,\r\n    );\r\n  }\r\n\r\n  private _applyCounterCreate(op: ObjectOperation): LiveCounterUpdate | LiveObjectUpdateNoop {\r\n    if (this._createOperationIsMerged) {\r\n      // There can't be two different create operation for the same object id, because the object id\r\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\r\n      // if we already merged it once.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveCounter._applyCounterCreate()',\r\n        `skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    return this._mergeInitialDataFromCreateOperation(op);\r\n  }\r\n\r\n  private _applyCounterInc(op: CounterOp): LiveCounterUpdate {\r\n    this._dataRef.data += op.amount;\r\n    return { update: { amount: op.amount } };\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport { BatchContext } from './batchcontext';\r\nimport { LiveCounter } from './livecounter';\r\nimport { Objects } from './objects';\r\n\r\nexport class BatchContextLiveCounter {\r\n  private _client: BaseClient;\r\n\r\n  constructor(\r\n    private _batchContext: BatchContext,\r\n    private _objects: Objects,\r\n    private _counter: LiveCounter,\r\n  ) {\r\n    this._client = this._objects.getClient();\r\n  }\r\n\r\n  value(): number {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    return this._counter.value();\r\n  }\r\n\r\n  increment(amount: number): void {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    const msg = LiveCounter.createCounterIncMessage(this._objects, this._counter.getObjectId(), amount);\r\n    this._batchContext.queueMessage(msg);\r\n  }\r\n\r\n  decrement(amount: number): void {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    // do an explicit type safety check here before negating the amount value,\r\n    // so we don't unintentionally change the type sent by a user\r\n    if (typeof amount !== 'number') {\r\n      throw new this._client.ErrorInfo('Counter value decrement should be a number', 40003, 400);\r\n    }\r\n\r\n    this.increment(-amount);\r\n  }\r\n}\r\n", "var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "export const DEFAULTS = {\r\n  gcInterval: 1000 * 60 * 5, // 5 minutes\r\n  /**\r\n   * Must be > 2 minutes to ensure we keep tombstones long enough to avoid the possibility of receiving an operation\r\n   * with an earlier serial that would not have been applied if the tombstone still existed.\r\n   *\r\n   * Applies both for map entries tombstones and object tombstones.\r\n   */\r\n  gcGracePeriod: 1000 * 60 * 60 * 24, // 24 hours\r\n};\r\n", "import { dequal } from 'dequal';\r\n\r\nimport type { Bufferlike } from 'common/platform';\r\nimport type * as API from '../../../ably';\r\nimport { DEFAULTS } from './defaults';\r\nimport { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\r\nimport { ObjectId } from './objectid';\r\nimport {\r\n  MapEntry,\r\n  MapOp,\r\n  MapSemantics,\r\n  ObjectMessage,\r\n  ObjectOperation,\r\n  ObjectOperationAction,\r\n  ObjectState,\r\n} from './objectmessage';\r\nimport { Objects } from './objects';\r\n\r\nexport type PrimitiveObjectValue = string | number | boolean | Bufferlike;\r\n\r\nexport interface ObjectIdObjectData {\r\n  /** A reference to another object, used to support composable object structures. */\r\n  objectId: string;\r\n}\r\n\r\nexport interface ValueObjectData {\r\n  /** Can be set by the client to indicate that value in `string` or `bytes` field have an encoding. */\r\n  encoding?: string;\r\n  /** A primitive boolean leaf value in the object graph. Only one value field can be set. */\r\n  boolean?: boolean;\r\n  /** A primitive binary leaf value in the object graph. Only one value field can be set. */\r\n  bytes?: Bufferlike;\r\n  /** A primitive number leaf value in the object graph. Only one value field can be set. */\r\n  number?: number;\r\n  /** A primitive string leaf value in the object graph. Only one value field can be set. */\r\n  string?: string;\r\n}\r\n\r\nexport type ObjectData = ObjectIdObjectData | ValueObjectData;\r\n\r\nexport interface LiveMapEntry {\r\n  tombstone: boolean;\r\n  /**\r\n   * Can't use serial from the operation that deleted the entry for the same reason as for {@link LiveObject} tombstones, see explanation there.\r\n   */\r\n  tombstonedAt: number | undefined;\r\n  timeserial: string | undefined;\r\n  data: ObjectData | undefined;\r\n}\r\n\r\nexport interface LiveMapData extends LiveObjectData {\r\n  data: Map<string, LiveMapEntry>;\r\n}\r\n\r\nexport interface LiveMapUpdate<T extends API.LiveMapType> extends LiveObjectUpdate {\r\n  update: { [keyName in keyof T & string]?: 'updated' | 'removed' };\r\n}\r\n\r\nexport class LiveMap<T extends API.LiveMapType> extends LiveObject<LiveMapData, LiveMapUpdate<T>> {\r\n  constructor(\r\n    objects: Objects,\r\n    private _semantics: MapSemantics,\r\n    objectId: string,\r\n  ) {\r\n    super(objects, objectId);\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveMap} instance with an empty map data.\r\n   *\r\n   * @internal\r\n   */\r\n  static zeroValue<T extends API.LiveMapType>(objects: Objects, objectId: string): LiveMap<T> {\r\n    return new LiveMap<T>(objects, MapSemantics.LWW, objectId);\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveMap} instance based on the provided object state.\r\n   * The provided object state must hold a valid map object data.\r\n   *\r\n   * @internal\r\n   */\r\n  static fromObjectState<T extends API.LiveMapType>(objects: Objects, objectState: ObjectState): LiveMap<T> {\r\n    const obj = new LiveMap<T>(objects, objectState.map?.semantics!, objectState.objectId);\r\n    obj.overrideWithObjectState(objectState);\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Returns a {@link LiveMap} instance based on the provided MAP_CREATE object operation.\r\n   * The provided object operation must hold a valid map object data.\r\n   *\r\n   * @internal\r\n   */\r\n  static fromObjectOperation<T extends API.LiveMapType>(\r\n    objects: Objects,\r\n    objectOperation: ObjectOperation,\r\n  ): LiveMap<T> {\r\n    const obj = new LiveMap<T>(objects, objectOperation.map?.semantics!, objectOperation.objectId);\r\n    obj._mergeInitialDataFromCreateOperation(objectOperation);\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createMapSetMessage<TKey extends keyof API.LiveMapType & string>(\r\n    objects: Objects,\r\n    objectId: string,\r\n    key: TKey,\r\n    value: API.LiveMapType[TKey],\r\n  ): ObjectMessage {\r\n    const client = objects.getClient();\r\n\r\n    LiveMap.validateKeyValue(objects, key, value);\r\n\r\n    let objectData: ObjectData;\r\n    if (value instanceof LiveObject) {\r\n      const typedObjectData: ObjectIdObjectData = { objectId: value.getObjectId() };\r\n      objectData = typedObjectData;\r\n    } else {\r\n      const typedObjectData: ValueObjectData = {};\r\n      if (typeof value === 'string') {\r\n        typedObjectData.string = value;\r\n      } else if (typeof value === 'number') {\r\n        typedObjectData.number = value;\r\n      } else if (typeof value === 'boolean') {\r\n        typedObjectData.boolean = value;\r\n      } else {\r\n        typedObjectData.bytes = value as Bufferlike;\r\n      }\r\n      objectData = typedObjectData;\r\n    }\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          action: ObjectOperationAction.MAP_SET,\r\n          objectId,\r\n          mapOp: {\r\n            key,\r\n            data: objectData,\r\n          },\r\n        } as ObjectOperation,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createMapRemoveMessage<TKey extends keyof API.LiveMapType & string>(\r\n    objects: Objects,\r\n    objectId: string,\r\n    key: TKey,\r\n  ): ObjectMessage {\r\n    const client = objects.getClient();\r\n\r\n    if (typeof key !== 'string') {\r\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\r\n    }\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          action: ObjectOperationAction.MAP_REMOVE,\r\n          objectId,\r\n          mapOp: { key },\r\n        } as ObjectOperation,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static validateKeyValue<TKey extends keyof API.LiveMapType & string>(\r\n    objects: Objects,\r\n    key: TKey,\r\n    value: API.LiveMapType[TKey],\r\n  ): void {\r\n    const client = objects.getClient();\r\n\r\n    if (typeof key !== 'string') {\r\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\r\n    }\r\n\r\n    if (\r\n      typeof value !== 'string' &&\r\n      typeof value !== 'number' &&\r\n      typeof value !== 'boolean' &&\r\n      !client.Platform.BufferUtils.isBuffer(value) &&\r\n      !(value instanceof LiveObject)\r\n    ) {\r\n      throw new client.ErrorInfo('Map value data type is unsupported', 40013, 400);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static async createMapCreateMessage(objects: Objects, entries?: API.LiveMapType): Promise<ObjectMessage> {\r\n    const client = objects.getClient();\r\n\r\n    if (entries !== undefined && (entries === null || typeof entries !== 'object')) {\r\n      throw new client.ErrorInfo('Map entries should be a key-value object', 40003, 400);\r\n    }\r\n\r\n    Object.entries(entries ?? {}).forEach(([key, value]) => LiveMap.validateKeyValue(objects, key, value));\r\n\r\n    const initialValueObj = LiveMap.createInitialValueObject(entries);\r\n    const { encodedInitialValue, format } = ObjectMessage.encodeInitialValue(initialValueObj, client);\r\n    const nonce = client.Utils.cheapRandStr();\r\n    const msTimestamp = await client.getTimestamp(true);\r\n\r\n    const objectId = ObjectId.fromInitialValue(\r\n      client.Platform,\r\n      'map',\r\n      encodedInitialValue,\r\n      nonce,\r\n      msTimestamp,\r\n    ).toString();\r\n\r\n    const msg = ObjectMessage.fromValues(\r\n      {\r\n        operation: {\r\n          ...initialValueObj,\r\n          action: ObjectOperationAction.MAP_CREATE,\r\n          objectId,\r\n          nonce,\r\n          initialValue: encodedInitialValue,\r\n          initialValueEncoding: format,\r\n        } as ObjectOperation,\r\n      },\r\n      client.Utils,\r\n      client.MessageEncoding,\r\n    );\r\n\r\n    return msg;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  static createInitialValueObject(entries?: API.LiveMapType): Pick<ObjectOperation, 'map'> {\r\n    const mapEntries: Record<string, MapEntry> = {};\r\n\r\n    Object.entries(entries ?? {}).forEach(([key, value]) => {\r\n      let objectData: ObjectData;\r\n      if (value instanceof LiveObject) {\r\n        const typedObjectData: ObjectIdObjectData = { objectId: value.getObjectId() };\r\n        objectData = typedObjectData;\r\n      } else {\r\n        const typedObjectData: ValueObjectData = {};\r\n        if (typeof value === 'string') {\r\n          typedObjectData.string = value;\r\n        } else if (typeof value === 'number') {\r\n          typedObjectData.number = value;\r\n        } else if (typeof value === 'boolean') {\r\n          typedObjectData.boolean = value;\r\n        } else {\r\n          typedObjectData.bytes = value as Bufferlike;\r\n        }\r\n        objectData = typedObjectData;\r\n      }\r\n\r\n      mapEntries[key] = {\r\n        data: objectData,\r\n      };\r\n    });\r\n\r\n    return {\r\n      map: {\r\n        semantics: MapSemantics.LWW,\r\n        entries: mapEntries,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns the value associated with the specified key in the underlying Map object.\r\n   *\r\n   * - If this map object is tombstoned (deleted), `undefined` is returned.\r\n   * - If no entry is associated with the specified key, `undefined` is returned.\r\n   * - If map entry is tombstoned (deleted), `undefined` is returned.\r\n   * - If the value associated with the provided key is an objectId string of another LiveObject, a reference to that LiveObject\r\n   * is returned, provided it exists in the local pool and is not tombstoned. Otherwise, `undefined` is returned.\r\n   * - If the value is not an objectId, then that value is returned.\r\n   */\r\n  // force the key to be of type string as we only allow strings as key in a map\r\n  get<TKey extends keyof T & string>(key: TKey): T[TKey] | undefined {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n\r\n    if (this.isTombstoned()) {\r\n      return undefined as T[TKey];\r\n    }\r\n\r\n    const element = this._dataRef.data.get(key);\r\n\r\n    if (element === undefined) {\r\n      return undefined as T[TKey];\r\n    }\r\n\r\n    if (element.tombstone === true) {\r\n      return undefined as T[TKey];\r\n    }\r\n\r\n    // data always exists for non-tombstoned elements\r\n    return this._getResolvedValueFromObjectData(element.data!) as T[TKey];\r\n  }\r\n\r\n  size(): number {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n\r\n    let size = 0;\r\n    for (const value of this._dataRef.data.values()) {\r\n      if (this._isMapEntryTombstoned(value)) {\r\n        // should not count tombstoned entries\r\n        continue;\r\n      }\r\n\r\n      size++;\r\n    }\r\n\r\n    return size;\r\n  }\r\n\r\n  *entries<TKey extends keyof T & string>(): IterableIterator<[TKey, T[TKey]]> {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n\r\n    for (const [key, entry] of this._dataRef.data.entries()) {\r\n      if (this._isMapEntryTombstoned(entry)) {\r\n        // do not return tombstoned entries\r\n        continue;\r\n      }\r\n\r\n      // data always exists for non-tombstoned elements\r\n      const value = this._getResolvedValueFromObjectData(entry.data!) as T[TKey];\r\n      yield [key as TKey, value];\r\n    }\r\n  }\r\n\r\n  *keys<TKey extends keyof T & string>(): IterableIterator<TKey> {\r\n    for (const [key] of this.entries<TKey>()) {\r\n      yield key;\r\n    }\r\n  }\r\n\r\n  *values<TKey extends keyof T & string>(): IterableIterator<T[TKey]> {\r\n    for (const [_, value] of this.entries<TKey>()) {\r\n      yield value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a MAP_SET operation to the realtime system to set a key on this LiveMap object to a specified value.\r\n   *\r\n   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when\r\n   * the published MAP_SET operation is echoed back to the client and applied to the object following the regular\r\n   * operation application procedure.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\r\n   */\r\n  async set<TKey extends keyof T & string>(key: TKey, value: T[TKey]): Promise<void> {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    const msg = LiveMap.createMapSetMessage(this._objects, this.getObjectId(), key, value);\r\n    return this._objects.publish([msg]);\r\n  }\r\n\r\n  /**\r\n   * Send a MAP_REMOVE operation to the realtime system to tombstone a key on this LiveMap object.\r\n   *\r\n   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when\r\n   * the published MAP_REMOVE operation is echoed back to the client and applied to the object following the regular\r\n   * operation application procedure.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\r\n   */\r\n  async remove<TKey extends keyof T & string>(key: TKey): Promise<void> {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    const msg = LiveMap.createMapRemoveMessage(this._objects, this.getObjectId(), key);\r\n    return this._objects.publish([msg]);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  applyOperation(op: ObjectOperation, msg: ObjectMessage): void {\r\n    if (op.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    const opSerial = msg.serial!;\r\n    const opSiteCode = msg.siteCode!;\r\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap.applyOperation()',\r\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return;\r\n    }\r\n    // should update stored site serial immediately. doesn't matter if we successfully apply the op,\r\n    // as it's important to mark that the op was processed by the object\r\n    this._siteTimeserials[opSiteCode] = opSerial;\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned so the operation cannot be applied\r\n      return;\r\n    }\r\n\r\n    let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\r\n    switch (op.action) {\r\n      case ObjectOperationAction.MAP_CREATE:\r\n        update = this._applyMapCreate(op);\r\n        break;\r\n\r\n      case ObjectOperationAction.MAP_SET:\r\n        if (this._client.Utils.isNil(op.mapOp)) {\r\n          this._throwNoPayloadError(op);\r\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\r\n          return;\r\n        } else {\r\n          update = this._applyMapSet(op.mapOp, opSerial);\r\n        }\r\n        break;\r\n\r\n      case ObjectOperationAction.MAP_REMOVE:\r\n        if (this._client.Utils.isNil(op.mapOp)) {\r\n          this._throwNoPayloadError(op);\r\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\r\n          return;\r\n        } else {\r\n          update = this._applyMapRemove(op.mapOp, opSerial);\r\n        }\r\n        break;\r\n\r\n      case ObjectOperationAction.OBJECT_DELETE:\r\n        update = this._applyObjectDelete();\r\n        break;\r\n\r\n      default:\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n    }\r\n\r\n    this.notifyUpdated(update);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  overrideWithObjectState(objectState: ObjectState): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    if (objectState.objectId !== this.getObjectId()) {\r\n      throw new this._client.ErrorInfo(\r\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveMap objectId=${this.getObjectId()}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    if (objectState.map?.semantics !== this._semantics) {\r\n      throw new this._client.ErrorInfo(\r\n        `Invalid object state: object state map semantics=${objectState.map?.semantics}; LiveMap semantics=${this._semantics}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    if (!this._client.Utils.isNil(objectState.createOp)) {\r\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\r\n      if (objectState.createOp.objectId !== this.getObjectId()) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveMap objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n\r\n      if (objectState.createOp.action !== ObjectOperationAction.MAP_CREATE) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveMap objectId=${this.getObjectId()}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n\r\n      if (objectState.createOp.map?.semantics !== this._semantics) {\r\n        throw new this._client.ErrorInfo(\r\n          `Invalid object state: object state createOp map semantics=${objectState.createOp.map?.semantics}; LiveMap semantics=${this._semantics}`,\r\n          92000,\r\n          500,\r\n        );\r\n      }\r\n    }\r\n\r\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the op.\r\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\r\n    this._siteTimeserials = objectState.siteTimeserials ?? {};\r\n\r\n    if (this.isTombstoned()) {\r\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\r\n      return { noop: true };\r\n    }\r\n\r\n    const previousDataRef = this._dataRef;\r\n    if (objectState.tombstone) {\r\n      // tombstone this object and ignore the data from the object state message\r\n      this.tombstone();\r\n    } else {\r\n      // override data for this object with data from the object state\r\n      this._createOperationIsMerged = false;\r\n      this._dataRef = this._liveMapDataFromMapEntries(objectState.map?.entries ?? {});\r\n      if (!this._client.Utils.isNil(objectState.createOp)) {\r\n        this._mergeInitialDataFromCreateOperation(objectState.createOp);\r\n      }\r\n    }\r\n\r\n    // if object got tombstoned, the update object will include all data that got cleared.\r\n    // otherwise it is a diff between previous value and new value from object state.\r\n    return this._updateFromDataDiff(previousDataRef, this._dataRef);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  onGCInterval(): void {\r\n    // should remove any tombstoned entries from the underlying map data that have exceeded the GC grace period\r\n\r\n    const keysToDelete: string[] = [];\r\n    for (const [key, value] of this._dataRef.data.entries()) {\r\n      if (value.tombstone === true && Date.now() - value.tombstonedAt! >= DEFAULTS.gcGracePeriod) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n\r\n    keysToDelete.forEach((x) => this._dataRef.data.delete(x));\r\n  }\r\n\r\n  protected _getZeroValueData(): LiveMapData {\r\n    return { data: new Map<string, LiveMapEntry>() };\r\n  }\r\n\r\n  protected _updateFromDataDiff(prevDataRef: LiveMapData, newDataRef: LiveMapData): LiveMapUpdate<T> {\r\n    const update: LiveMapUpdate<T> = { update: {} };\r\n\r\n    for (const [key, currentEntry] of prevDataRef.data.entries()) {\r\n      const typedKey: keyof T & string = key;\r\n      // any non-tombstoned properties that exist on a current map, but not in the new data - got removed\r\n      if (currentEntry.tombstone === false && !newDataRef.data.has(typedKey)) {\r\n        update.update[typedKey] = 'removed';\r\n      }\r\n    }\r\n\r\n    for (const [key, newEntry] of newDataRef.data.entries()) {\r\n      const typedKey: keyof T & string = key;\r\n      if (!prevDataRef.data.has(typedKey)) {\r\n        // if property does not exist in the current map, but new data has it as a non-tombstoned property - got updated\r\n        if (newEntry.tombstone === false) {\r\n          update.update[typedKey] = 'updated';\r\n          continue;\r\n        }\r\n\r\n        // otherwise, if new data has this prop tombstoned - do nothing, as property didn't exist anyway\r\n        if (newEntry.tombstone === true) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // properties that exist both in current and new map data need to have their values compared to decide on the update type\r\n      const currentEntry = prevDataRef.data.get(typedKey)!;\r\n\r\n      // compare tombstones first\r\n      if (currentEntry.tombstone === true && newEntry.tombstone === false) {\r\n        // current prop is tombstoned, but new is not. it means prop was updated to a meaningful value\r\n        update.update[typedKey] = 'updated';\r\n        continue;\r\n      }\r\n      if (currentEntry.tombstone === false && newEntry.tombstone === true) {\r\n        // current prop is not tombstoned, but new is. it means prop was removed\r\n        update.update[typedKey] = 'removed';\r\n        continue;\r\n      }\r\n      if (currentEntry.tombstone === true && newEntry.tombstone === true) {\r\n        // both props are tombstoned - treat as noop, as there is no data to compare.\r\n        continue;\r\n      }\r\n\r\n      // both props exist and are not tombstoned, need to compare values with deep equals to see if it was changed\r\n      const valueChanged = !dequal(currentEntry.data, newEntry.data);\r\n      if (valueChanged) {\r\n        update.update[typedKey] = 'updated';\r\n        continue;\r\n      }\r\n    }\r\n\r\n    return update;\r\n  }\r\n\r\n  protected _mergeInitialDataFromCreateOperation(objectOperation: ObjectOperation): LiveMapUpdate<T> {\r\n    if (this._client.Utils.isNil(objectOperation.map)) {\r\n      // if a map object is missing for the MAP_CREATE op, the initial value is implicitly an empty map.\r\n      // in this case there is nothing to merge into the current map, so we can just end processing the op.\r\n      return { update: {} };\r\n    }\r\n\r\n    const aggregatedUpdate: LiveMapUpdate<T> = { update: {} };\r\n    // in order to apply MAP_CREATE op for an existing map, we should merge their underlying entries keys.\r\n    // we can do this by iterating over entries from MAP_CREATE op and apply changes on per-key basis as if we had MAP_SET, MAP_REMOVE operations.\r\n    Object.entries(objectOperation.map.entries ?? {}).forEach(([key, entry]) => {\r\n      // for a MAP_CREATE operation we must use the serial value available on an entry, instead of a serial on a message\r\n      const opSerial = entry.timeserial;\r\n      let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\r\n      if (entry.tombstone === true) {\r\n        // entry in MAP_CREATE op is removed, try to apply MAP_REMOVE op\r\n        update = this._applyMapRemove({ key }, opSerial);\r\n      } else {\r\n        // entry in MAP_CREATE op is not removed, try to set it via MAP_SET op\r\n        update = this._applyMapSet({ key, data: entry.data }, opSerial);\r\n      }\r\n\r\n      // skip noop updates\r\n      if ((update as LiveObjectUpdateNoop).noop) {\r\n        return;\r\n      }\r\n\r\n      // otherwise copy update data to aggregated update\r\n      Object.assign(aggregatedUpdate.update, update.update);\r\n    });\r\n\r\n    this._createOperationIsMerged = true;\r\n\r\n    return aggregatedUpdate;\r\n  }\r\n\r\n  private _throwNoPayloadError(op: ObjectOperation): void {\r\n    throw new this._client.ErrorInfo(\r\n      `No payload found for ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\r\n      92000,\r\n      500,\r\n    );\r\n  }\r\n\r\n  private _applyMapCreate(op: ObjectOperation): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    if (this._createOperationIsMerged) {\r\n      // There can't be two different create operation for the same object id, because the object id\r\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\r\n      // if we already merged it once.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap._applyMapCreate()',\r\n        `skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    if (this._semantics !== op.map?.semantics) {\r\n      throw new this._client.ErrorInfo(\r\n        `Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${op.map?.semantics}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    return this._mergeInitialDataFromCreateOperation(op);\r\n  }\r\n\r\n  private _applyMapSet(op: MapOp, opSerial: string | undefined): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    const { ErrorInfo, Utils } = this._client;\r\n\r\n    const existingEntry = this._dataRef.data.get(op.key);\r\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\r\n      // the operation's serial <= the entry's serial, ignore the operation.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap._applyMapSet()',\r\n        `skipping update for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    if (\r\n      Utils.isNil(op.data) ||\r\n      (Utils.isNil(op.data.objectId) &&\r\n        Utils.isNil(op.data.boolean) &&\r\n        Utils.isNil(op.data.bytes) &&\r\n        Utils.isNil(op.data.number) &&\r\n        Utils.isNil(op.data.string))\r\n    ) {\r\n      throw new ErrorInfo(\r\n        `Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key=${op.key}`,\r\n        92000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    let liveData: ObjectData;\r\n    if (!Utils.isNil(op.data.objectId)) {\r\n      liveData = { objectId: op.data.objectId } as ObjectIdObjectData;\r\n      // this MAP_SET op is setting a key to point to another object via its object id,\r\n      // but it is possible that we don't have the corresponding object in the pool yet (for example, we haven't seen the *_CREATE op for it).\r\n      // we don't want to return undefined from this map's .get() method even if we don't have the object,\r\n      // so instead we create a zero-value object for that object id if it not exists.\r\n      this._objects.getPool().createZeroValueObjectIfNotExists(op.data.objectId);\r\n    } else {\r\n      liveData = {\r\n        encoding: op.data.encoding,\r\n        boolean: op.data.boolean,\r\n        bytes: op.data.bytes,\r\n        number: op.data.number,\r\n        string: op.data.string,\r\n      } as ValueObjectData;\r\n    }\r\n\r\n    if (existingEntry) {\r\n      existingEntry.tombstone = false;\r\n      existingEntry.tombstonedAt = undefined;\r\n      existingEntry.timeserial = opSerial;\r\n      existingEntry.data = liveData;\r\n    } else {\r\n      const newEntry: LiveMapEntry = {\r\n        tombstone: false,\r\n        tombstonedAt: undefined,\r\n        timeserial: opSerial,\r\n        data: liveData,\r\n      };\r\n      this._dataRef.data.set(op.key, newEntry);\r\n    }\r\n\r\n    const update: LiveMapUpdate<T> = { update: {} };\r\n    const typedKey: keyof T & string = op.key;\r\n    update.update[typedKey] = 'updated';\r\n\r\n    return update;\r\n  }\r\n\r\n  private _applyMapRemove(op: MapOp, opSerial: string | undefined): LiveMapUpdate<T> | LiveObjectUpdateNoop {\r\n    const existingEntry = this._dataRef.data.get(op.key);\r\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\r\n      // the operation's serial <= the entry's serial, ignore the operation.\r\n      this._client.Logger.logAction(\r\n        this._client.logger,\r\n        this._client.Logger.LOG_MICRO,\r\n        'LiveMap._applyMapRemove()',\r\n        `skipping remove for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\r\n      );\r\n      return { noop: true };\r\n    }\r\n\r\n    if (existingEntry) {\r\n      existingEntry.tombstone = true;\r\n      existingEntry.tombstonedAt = Date.now();\r\n      existingEntry.timeserial = opSerial;\r\n      existingEntry.data = undefined;\r\n    } else {\r\n      const newEntry: LiveMapEntry = {\r\n        tombstone: true,\r\n        tombstonedAt: Date.now(),\r\n        timeserial: opSerial,\r\n        data: undefined,\r\n      };\r\n      this._dataRef.data.set(op.key, newEntry);\r\n    }\r\n\r\n    const update: LiveMapUpdate<T> = { update: {} };\r\n    const typedKey: keyof T & string = op.key;\r\n    update.update[typedKey] = 'removed';\r\n\r\n    return update;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the serials of the given operation and entry indicate that\r\n   * the operation should be applied to the entry, following the CRDT semantics of this LiveMap.\r\n   */\r\n  private _canApplyMapOperation(mapEntrySerial: string | undefined, opSerial: string | undefined): boolean {\r\n    // for LWW CRDT semantics (the only supported LiveMap semantic) an operation\r\n    // should only be applied if its serial is strictly greater (\"after\") than an entry's serial.\r\n\r\n    if (!mapEntrySerial && !opSerial) {\r\n      // if both serials are nullish or empty strings, we treat them as the \"earliest possible\" serials,\r\n      // in which case they are \"equal\", so the operation should not be applied\r\n      return false;\r\n    }\r\n\r\n    if (!mapEntrySerial) {\r\n      // any operation serial is greater than non-existing entry serial\r\n      return true;\r\n    }\r\n\r\n    if (!opSerial) {\r\n      // non-existing operation serial is lower than any entry serial\r\n      return false;\r\n    }\r\n\r\n    // if both serials exist, compare them lexicographically\r\n    return opSerial > mapEntrySerial;\r\n  }\r\n\r\n  private _liveMapDataFromMapEntries(entries: Record<string, MapEntry>): LiveMapData {\r\n    const liveMapData: LiveMapData = {\r\n      data: new Map<string, LiveMapEntry>(),\r\n    };\r\n\r\n    // need to iterate over entries to correctly process optional parameters\r\n    Object.entries(entries ?? {}).forEach(([key, entry]) => {\r\n      let liveData: ObjectData | undefined = undefined;\r\n\r\n      if (!this._client.Utils.isNil(entry.data)) {\r\n        if (!this._client.Utils.isNil(entry.data.objectId)) {\r\n          liveData = { objectId: entry.data.objectId } as ObjectIdObjectData;\r\n        } else {\r\n          liveData = {\r\n            encoding: entry.data.encoding,\r\n            boolean: entry.data.boolean,\r\n            bytes: entry.data.bytes,\r\n            number: entry.data.number,\r\n            string: entry.data.string,\r\n          } as ValueObjectData;\r\n        }\r\n      }\r\n\r\n      const liveDataEntry: LiveMapEntry = {\r\n        timeserial: entry.timeserial,\r\n        data: liveData,\r\n        // consider object as tombstoned only if we received an explicit flag stating that. otherwise it exists\r\n        tombstone: entry.tombstone === true,\r\n        tombstonedAt: entry.tombstone === true ? Date.now() : undefined,\r\n      };\r\n\r\n      liveMapData.data.set(key, liveDataEntry);\r\n    });\r\n\r\n    return liveMapData;\r\n  }\r\n\r\n  /**\r\n   * Returns value as is if MapEntry stores a primitive type, or a reference to another LiveObject from the pool if it stores an objectId.\r\n   */\r\n  private _getResolvedValueFromObjectData(data: ObjectData): PrimitiveObjectValue | LiveObject | undefined {\r\n    // if object data stores one of the primitive values, just return it as is.\r\n    const asValueObject = data as ValueObjectData;\r\n    if (asValueObject.boolean !== undefined) {\r\n      return asValueObject.boolean;\r\n    }\r\n    if (asValueObject.bytes !== undefined) {\r\n      return asValueObject.bytes;\r\n    }\r\n    if (asValueObject.number !== undefined) {\r\n      return asValueObject.number;\r\n    }\r\n    if (asValueObject.string !== undefined) {\r\n      return asValueObject.string;\r\n    }\r\n\r\n    // otherwise, it has an objectId reference, and we should get the actual object from the pool\r\n    const objectId = (data as ObjectIdObjectData).objectId;\r\n    const refObject: LiveObject | undefined = this._objects.getPool().get(objectId);\r\n    if (!refObject) {\r\n      return undefined;\r\n    }\r\n\r\n    if (refObject.isTombstoned()) {\r\n      // tombstoned objects must not be surfaced to the end users\r\n      return undefined;\r\n    }\r\n\r\n    return refObject;\r\n  }\r\n\r\n  private _isMapEntryTombstoned(entry: LiveMapEntry): boolean {\r\n    if (entry.tombstone === true) {\r\n      return true;\r\n    }\r\n\r\n    // data always exists for non-tombstoned entries\r\n    const data = entry.data!;\r\n    if ('objectId' in data) {\r\n      const refObject = this._objects.getPool().get(data.objectId);\r\n\r\n      if (refObject?.isTombstoned()) {\r\n        // entry that points to tombstoned object should be considered tombstoned as well\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n", "import type * as API from '../../../ably';\r\nimport { BatchContext } from './batchcontext';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject } from './liveobject';\r\nimport { Objects } from './objects';\r\n\r\nexport class BatchContextLiveMap<T extends API.LiveMapType> {\r\n  constructor(\r\n    private _batchContext: BatchContext,\r\n    private _objects: Objects,\r\n    private _map: LiveMap<T>,\r\n  ) {}\r\n\r\n  get<TKey extends keyof T & string>(key: TKey): T[TKey] | undefined {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    const value = this._map.get(key);\r\n    if (value instanceof LiveObject) {\r\n      return this._batchContext.getWrappedObject(value.getObjectId()) as T[TKey];\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  size(): number {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    return this._map.size();\r\n  }\r\n\r\n  *entries<TKey extends keyof T & string>(): IterableIterator<[TKey, T[TKey]]> {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    yield* this._map.entries();\r\n  }\r\n\r\n  *keys<TKey extends keyof T & string>(): IterableIterator<TKey> {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    yield* this._map.keys();\r\n  }\r\n\r\n  *values<TKey extends keyof T & string>(): IterableIterator<T[TKey]> {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    yield* this._map.values();\r\n  }\r\n\r\n  set<TKey extends keyof T & string>(key: TKey, value: T[TKey]): void {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    const msg = LiveMap.createMapSetMessage(this._objects, this._map.getObjectId(), key, value);\r\n    this._batchContext.queueMessage(msg);\r\n  }\r\n\r\n  remove<TKey extends keyof T & string>(key: TKey): void {\r\n    this._objects.throwIfInvalidWriteApiConfiguration();\r\n    this._batchContext.throwIfClosed();\r\n    const msg = LiveMap.createMapRemoveMessage(this._objects, this._map.getObjectId(), key);\r\n    this._batchContext.queueMessage(msg);\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport { DEFAULTS } from './defaults';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject } from './liveobject';\r\nimport { ObjectId } from './objectid';\r\nimport { Objects } from './objects';\r\n\r\nexport const ROOT_OBJECT_ID = 'root';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ObjectsPool {\r\n  private _client: BaseClient;\r\n  private _pool: Map<string, LiveObject>;\r\n  private _gcInterval: ReturnType<typeof setInterval>;\r\n\r\n  constructor(private _objects: Objects) {\r\n    this._client = this._objects.getClient();\r\n    this._pool = this._createInitialPool();\r\n    this._gcInterval = setInterval(() => {\r\n      this._onGCInterval();\r\n    }, DEFAULTS.gcInterval);\r\n    // call nodejs's Timeout.unref to not require Node.js event loop to remain active due to this interval. see https://nodejs.org/api/timers.html#timeoutunref\r\n    this._gcInterval.unref?.();\r\n  }\r\n\r\n  get(objectId: string): LiveObject | undefined {\r\n    return this._pool.get(objectId);\r\n  }\r\n\r\n  /**\r\n   * Deletes objects from the pool for which object ids are not found in the provided array of ids.\r\n   */\r\n  deleteExtraObjectIds(objectIds: string[]): void {\r\n    const poolObjectIds = [...this._pool.keys()];\r\n    const extraObjectIds = poolObjectIds.filter((x) => !objectIds.includes(x));\r\n\r\n    extraObjectIds.forEach((x) => this._pool.delete(x));\r\n  }\r\n\r\n  set(objectId: string, liveObject: LiveObject): void {\r\n    this._pool.set(objectId, liveObject);\r\n  }\r\n\r\n  /**\r\n   * Removes all objects but root from the pool and clears the data for root.\r\n   * Does not create a new root object, so the reference to the root object remains the same.\r\n   */\r\n  resetToInitialPool(emitUpdateEvents: boolean): void {\r\n    // clear the pool first and keep the root object\r\n    const root = this._pool.get(ROOT_OBJECT_ID)!;\r\n    this._pool.clear();\r\n    this._pool.set(root.getObjectId(), root);\r\n\r\n    // clear the data, this will only clear the root object\r\n    this.clearObjectsData(emitUpdateEvents);\r\n  }\r\n\r\n  /**\r\n   * Clears the data stored for all objects in the pool.\r\n   */\r\n  clearObjectsData(emitUpdateEvents: boolean): void {\r\n    for (const object of this._pool.values()) {\r\n      const update = object.clearData();\r\n      if (emitUpdateEvents) {\r\n        object.notifyUpdated(update);\r\n      }\r\n    }\r\n  }\r\n\r\n  createZeroValueObjectIfNotExists(objectId: string): LiveObject {\r\n    const existingObject = this.get(objectId);\r\n    if (existingObject) {\r\n      return existingObject;\r\n    }\r\n\r\n    const parsedObjectId = ObjectId.fromString(this._client, objectId);\r\n    let zeroValueObject: LiveObject;\r\n    switch (parsedObjectId.type) {\r\n      case 'map': {\r\n        zeroValueObject = LiveMap.zeroValue(this._objects, objectId);\r\n        break;\r\n      }\r\n\r\n      case 'counter':\r\n        zeroValueObject = LiveCounter.zeroValue(this._objects, objectId);\r\n        break;\r\n    }\r\n\r\n    this.set(objectId, zeroValueObject);\r\n    return zeroValueObject;\r\n  }\r\n\r\n  private _createInitialPool(): Map<string, LiveObject> {\r\n    const pool = new Map<string, LiveObject>();\r\n    const root = LiveMap.zeroValue(this._objects, ROOT_OBJECT_ID);\r\n    pool.set(root.getObjectId(), root);\r\n    return pool;\r\n  }\r\n\r\n  private _onGCInterval(): void {\r\n    const toDelete: string[] = [];\r\n    for (const [objectId, obj] of this._pool.entries()) {\r\n      // tombstoned objects should be removed from the pool if they have been tombstoned for longer than grace period.\r\n      // by removing them from the local pool, Objects plugin no longer keeps a reference to those objects, allowing JS's\r\n      // Garbage Collection to eventually free the memory for those objects, provided the user no longer references them either.\r\n      if (obj.isTombstoned() && Date.now() - obj.tombstonedAt()! >= DEFAULTS.gcGracePeriod) {\r\n        toDelete.push(objectId);\r\n        continue;\r\n      }\r\n\r\n      obj.onGCInterval();\r\n    }\r\n\r\n    toDelete.forEach((x) => this._pool.delete(x));\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type * as API from '../../../ably';\r\nimport { BatchContextLiveCounter } from './batchcontextlivecounter';\r\nimport { BatchContextLiveMap } from './batchcontextlivemap';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { ObjectMessage } from './objectmessage';\r\nimport { Objects } from './objects';\r\nimport { ROOT_OBJECT_ID } from './objectspool';\r\n\r\nexport class BatchContext {\r\n  private _client: BaseClient;\r\n  /** Maps object ids to the corresponding batch context object wrappers  */\r\n  private _wrappedObjects: Map<string, BatchContextLiveCounter | BatchContextLiveMap<API.LiveMapType>> = new Map();\r\n  private _queuedMessages: ObjectMessage[] = [];\r\n  private _isClosed = false;\r\n\r\n  constructor(\r\n    private _objects: Objects,\r\n    private _root: LiveMap<API.LiveMapType>,\r\n  ) {\r\n    this._client = _objects.getClient();\r\n    this._wrappedObjects.set(this._root.getObjectId(), new BatchContextLiveMap(this, this._objects, this._root));\r\n  }\r\n\r\n  getRoot<T extends API.LiveMapType = API.DefaultRoot>(): BatchContextLiveMap<T> {\r\n    this._objects.throwIfInvalidAccessApiConfiguration();\r\n    this.throwIfClosed();\r\n    return this.getWrappedObject(ROOT_OBJECT_ID) as BatchContextLiveMap<T>;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getWrappedObject(objectId: string): BatchContextLiveCounter | BatchContextLiveMap<API.LiveMapType> | undefined {\r\n    if (this._wrappedObjects.has(objectId)) {\r\n      return this._wrappedObjects.get(objectId);\r\n    }\r\n\r\n    const originObject = this._objects.getPool().get(objectId);\r\n    if (!originObject) {\r\n      return undefined;\r\n    }\r\n\r\n    let wrappedObject: BatchContextLiveCounter | BatchContextLiveMap<API.LiveMapType>;\r\n    if (originObject instanceof LiveMap) {\r\n      wrappedObject = new BatchContextLiveMap(this, this._objects, originObject);\r\n    } else if (originObject instanceof LiveCounter) {\r\n      wrappedObject = new BatchContextLiveCounter(this, this._objects, originObject);\r\n    } else {\r\n      throw new this._client.ErrorInfo(\r\n        `Unknown LiveObject instance type: objectId=${originObject.getObjectId()}`,\r\n        50000,\r\n        500,\r\n      );\r\n    }\r\n\r\n    this._wrappedObjects.set(objectId, wrappedObject);\r\n    return wrappedObject;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  throwIfClosed(): void {\r\n    if (this.isClosed()) {\r\n      throw new this._client.ErrorInfo('Batch is closed', 40000, 400);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  isClosed(): boolean {\r\n    return this._isClosed;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  close(): void {\r\n    this._isClosed = true;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  queueMessage(msg: ObjectMessage): void {\r\n    this._queuedMessages.push(msg);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  async flush(): Promise<void> {\r\n    try {\r\n      this.close();\r\n\r\n      if (this._queuedMessages.length > 0) {\r\n        await this._objects.publish(this._queuedMessages);\r\n      }\r\n    } finally {\r\n      this._wrappedObjects.clear();\r\n      this._queuedMessages = [];\r\n    }\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\r\nimport { ObjectMessage, ObjectState } from './objectmessage';\r\nimport { Objects } from './objects';\r\n\r\nexport interface LiveObjectDataEntry {\r\n  objectState: ObjectState;\r\n  objectType: 'LiveMap' | 'LiveCounter';\r\n}\r\n\r\nexport interface LiveCounterDataEntry extends LiveObjectDataEntry {\r\n  objectType: 'LiveCounter';\r\n}\r\n\r\nexport interface LiveMapDataEntry extends LiveObjectDataEntry {\r\n  objectType: 'LiveMap';\r\n}\r\n\r\nexport type AnyDataEntry = LiveCounterDataEntry | LiveMapDataEntry;\r\n\r\n// TODO: investigate if this class is still needed after changes with createOp. objects are now initialized from the stateObject and this class does minimal processing\r\n/**\r\n * @internal\r\n */\r\nexport class SyncObjectsDataPool {\r\n  private _client: BaseClient;\r\n  private _channel: RealtimeChannel;\r\n  private _pool: Map<string, AnyDataEntry>;\r\n\r\n  constructor(private _objects: Objects) {\r\n    this._client = this._objects.getClient();\r\n    this._channel = this._objects.getChannel();\r\n    this._pool = new Map<string, AnyDataEntry>();\r\n  }\r\n\r\n  entries() {\r\n    return this._pool.entries();\r\n  }\r\n\r\n  size(): number {\r\n    return this._pool.size;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this._pool.size === 0;\r\n  }\r\n\r\n  clear(): void {\r\n    this._pool.clear();\r\n  }\r\n\r\n  applyObjectSyncMessages(objectMessages: ObjectMessage[]): void {\r\n    for (const objectMessage of objectMessages) {\r\n      if (!objectMessage.object) {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\r\n          `object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const objectState = objectMessage.object;\r\n\r\n      if (objectState.counter) {\r\n        this._pool.set(objectState.objectId, this._createLiveCounterDataEntry(objectState));\r\n      } else if (objectState.map) {\r\n        this._pool.set(objectState.objectId, this._createLiveMapDataEntry(objectState));\r\n      } else {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\r\n          `received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private _createLiveCounterDataEntry(objectState: ObjectState): LiveCounterDataEntry {\r\n    const newEntry: LiveCounterDataEntry = {\r\n      objectState,\r\n      objectType: 'LiveCounter',\r\n    };\r\n\r\n    return newEntry;\r\n  }\r\n\r\n  private _createLiveMapDataEntry(objectState: ObjectState): LiveMapDataEntry {\r\n    const newEntry: LiveMapDataEntry = {\r\n      objectState,\r\n      objectType: 'LiveMap',\r\n    };\r\n\r\n    return newEntry;\r\n  }\r\n}\r\n", "import type BaseClient from 'common/lib/client/baseclient';\r\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\r\nimport type EventEmitter from 'common/lib/util/eventemitter';\r\nimport type * as API from '../../../ably';\r\nimport { BatchContext } from './batchcontext';\r\nimport { DEFAULTS } from './defaults';\r\nimport { LiveCounter } from './livecounter';\r\nimport { LiveMap } from './livemap';\r\nimport { LiveObject, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\r\nimport { ObjectMessage, ObjectOperationAction } from './objectmessage';\r\nimport { ObjectsPool, ROOT_OBJECT_ID } from './objectspool';\r\nimport { SyncObjectsDataPool } from './syncobjectsdatapool';\r\n\r\nexport enum ObjectsEvent {\r\n  syncing = 'syncing',\r\n  synced = 'synced',\r\n}\r\n\r\nexport enum ObjectsState {\r\n  initialized = 'initialized',\r\n  syncing = 'syncing',\r\n  synced = 'synced',\r\n}\r\n\r\nconst StateToEventsMap: Record<ObjectsState, ObjectsEvent | undefined> = {\r\n  initialized: undefined,\r\n  syncing: ObjectsEvent.syncing,\r\n  synced: ObjectsEvent.synced,\r\n};\r\n\r\nexport type ObjectsEventCallback = () => void;\r\n\r\nexport interface OnObjectsEventResponse {\r\n  off(): void;\r\n}\r\n\r\nexport type BatchCallback = (batchContext: BatchContext) => void;\r\n\r\nexport class Objects {\r\n  private _client: BaseClient;\r\n  private _channel: RealtimeChannel;\r\n  private _state: ObjectsState;\r\n  // composition over inheritance since we cannot import class directly into plugin code.\r\n  // instead we obtain a class type from the client\r\n  private _eventEmitterInternal: EventEmitter;\r\n  // related to RTC10, should have a separate EventEmitter for users of the library\r\n  private _eventEmitterPublic: EventEmitter;\r\n  private _objectsPool: ObjectsPool;\r\n  private _syncObjectsDataPool: SyncObjectsDataPool;\r\n  private _currentSyncId: string | undefined;\r\n  private _currentSyncCursor: string | undefined;\r\n  private _bufferedObjectOperations: ObjectMessage[];\r\n\r\n  // Used by tests\r\n  static _DEFAULTS = DEFAULTS;\r\n\r\n  constructor(channel: RealtimeChannel) {\r\n    this._channel = channel;\r\n    this._client = channel.client;\r\n    this._state = ObjectsState.initialized;\r\n    this._eventEmitterInternal = new this._client.EventEmitter(this._client.logger);\r\n    this._eventEmitterPublic = new this._client.EventEmitter(this._client.logger);\r\n    this._objectsPool = new ObjectsPool(this);\r\n    this._syncObjectsDataPool = new SyncObjectsDataPool(this);\r\n    this._bufferedObjectOperations = [];\r\n  }\r\n\r\n  /**\r\n   * When called without a type variable, we return a default root type which is based on globally defined interface for Objects feature.\r\n   * A user can provide an explicit type for the getRoot method to explicitly set the type structure on this particular channel.\r\n   * This is useful when working with multiple channels with different underlying data structure.\r\n   */\r\n  async getRoot<T extends API.LiveMapType = API.DefaultRoot>(): Promise<LiveMap<T>> {\r\n    this.throwIfInvalidAccessApiConfiguration();\r\n\r\n    // if we're not synced yet, wait for sync sequence to finish before returning root\r\n    if (this._state !== ObjectsState.synced) {\r\n      await this._eventEmitterInternal.once(ObjectsEvent.synced);\r\n    }\r\n\r\n    return this._objectsPool.get(ROOT_OBJECT_ID) as LiveMap<T>;\r\n  }\r\n\r\n  /**\r\n   * Provides access to the synchronous write API for Objects that can be used to batch multiple operations together in a single channel message.\r\n   */\r\n  async batch(callback: BatchCallback): Promise<void> {\r\n    this.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const root = await this.getRoot();\r\n    const context = new BatchContext(this, root);\r\n\r\n    try {\r\n      callback(context);\r\n      await context.flush();\r\n    } finally {\r\n      context.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a MAP_CREATE operation to the realtime system to create a new map object in the pool.\r\n   *\r\n   * Once the ACK message is received, the method returns the object from the local pool if it got created due to\r\n   * the echoed MAP_CREATE operation, or if it wasn't received yet, the method creates a new object locally using the provided data and returns it.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message. A promise is resolved with an object containing provided data.\r\n   */\r\n  async createMap<T extends API.LiveMapType>(entries?: T): Promise<LiveMap<T>> {\r\n    this.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const msg = await LiveMap.createMapCreateMessage(this, entries);\r\n    const objectId = msg.operation?.objectId!;\r\n\r\n    await this.publish([msg]);\r\n\r\n    // we may have already received the MAP_CREATE operation at this point, as it could arrive before the ACK for our publish message.\r\n    // this means the object might already exist in the local pool, having been added during the usual MAP_CREATE operation process.\r\n    // here we check if the object is present, and return it if found; otherwise, create a new object on the client side.\r\n    if (this._objectsPool.get(objectId)) {\r\n      return this._objectsPool.get(objectId) as LiveMap<T>;\r\n    }\r\n\r\n    // we haven't received the MAP_CREATE operation yet, so we can create a new map object using the locally constructed object operation.\r\n    // we don't know the serials for map entries, so we assign an \"earliest possible\" serial to each entry, so that any subsequent operation can be applied to them.\r\n    // we mark the MAP_CREATE operation as merged for the object, guaranteeing its idempotency and preventing it from being applied again when the operation arrives.\r\n    const map = LiveMap.fromObjectOperation<T>(this, msg.operation!);\r\n    this._objectsPool.set(objectId, map);\r\n\r\n    return map;\r\n  }\r\n\r\n  /**\r\n   * Send a COUNTER_CREATE operation to the realtime system to create a new counter object in the pool.\r\n   *\r\n   * Once the ACK message is received, the method returns the object from the local pool if it got created due to\r\n   * the echoed COUNTER_CREATE operation, or if it wasn't received yet, the method creates a new object locally using the provided data and returns it.\r\n   *\r\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message. A promise is resolved with an object containing provided data.\r\n   */\r\n  async createCounter(count?: number): Promise<LiveCounter> {\r\n    this.throwIfInvalidWriteApiConfiguration();\r\n\r\n    const msg = await LiveCounter.createCounterCreateMessage(this, count);\r\n    const objectId = msg.operation?.objectId!;\r\n\r\n    await this.publish([msg]);\r\n\r\n    // we may have already received the COUNTER_CREATE operation at this point, as it could arrive before the ACK for our publish message.\r\n    // this means the object might already exist in the local pool, having been added during the usual COUNTER_CREATE operation process.\r\n    // here we check if the object is present, and return it if found; otherwise, create a new object on the client side.\r\n    if (this._objectsPool.get(objectId)) {\r\n      return this._objectsPool.get(objectId) as LiveCounter;\r\n    }\r\n\r\n    // we haven't received the COUNTER_CREATE operation yet, so we can create a new counter object using the locally constructed object operation.\r\n    // we mark the COUNTER_CREATE operation as merged for the object, guaranteeing its idempotency. this ensures we don't double count the initial counter value when the operation arrives.\r\n    const counter = LiveCounter.fromObjectOperation(this, msg.operation!);\r\n    this._objectsPool.set(objectId, counter);\r\n\r\n    return counter;\r\n  }\r\n\r\n  on(event: ObjectsEvent, callback: ObjectsEventCallback): OnObjectsEventResponse {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n    this._eventEmitterPublic.on(event, callback);\r\n\r\n    const off = () => {\r\n      this._eventEmitterPublic.off(event, callback);\r\n    };\r\n\r\n    return { off };\r\n  }\r\n\r\n  off(event: ObjectsEvent, callback: ObjectsEventCallback): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n\r\n    // prevent accidentally calling .off without any arguments on an EventEmitter and removing all callbacks\r\n    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {\r\n      return;\r\n    }\r\n\r\n    this._eventEmitterPublic.off(event, callback);\r\n  }\r\n\r\n  offAll(): void {\r\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\r\n    this._eventEmitterPublic.off();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getPool(): ObjectsPool {\r\n    return this._objectsPool;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getChannel(): RealtimeChannel {\r\n    return this._channel;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  getClient(): BaseClient {\r\n    return this._client;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  handleObjectSyncMessages(objectMessages: ObjectMessage[], syncChannelSerial: string | null | undefined): void {\r\n    const { syncId, syncCursor } = this._parseSyncChannelSerial(syncChannelSerial);\r\n    const newSyncSequence = this._currentSyncId !== syncId;\r\n    if (newSyncSequence) {\r\n      this._startNewSync(syncId, syncCursor);\r\n    }\r\n\r\n    this._syncObjectsDataPool.applyObjectSyncMessages(objectMessages);\r\n\r\n    // if this is the last (or only) message in a sequence of sync updates, end the sync\r\n    if (!syncCursor) {\r\n      // defer the state change event until the next tick if this was a new sync sequence\r\n      // to allow any event listeners to process the start of the new sequence event that was emitted earlier during this event loop.\r\n      this._endSync(newSyncSequence);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  handleObjectMessages(objectMessages: ObjectMessage[]): void {\r\n    if (this._state !== ObjectsState.synced) {\r\n      // The client receives object messages in realtime over the channel concurrently with the sync sequence.\r\n      // Some of the incoming object messages may have already been applied to the objects described in\r\n      // the sync sequence, but others may not; therefore we must buffer these messages so that we can apply\r\n      // them to the objects once the sync is complete.\r\n      this._bufferedObjectOperations.push(...objectMessages);\r\n      return;\r\n    }\r\n\r\n    this._applyObjectMessages(objectMessages);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  onAttached(hasObjects?: boolean): void {\r\n    this._client.Logger.logAction(\r\n      this._client.logger,\r\n      this._client.Logger.LOG_MINOR,\r\n      'Objects.onAttached()',\r\n      `channel=${this._channel.name}, hasObjects=${hasObjects}`,\r\n    );\r\n\r\n    const fromInitializedState = this._state === ObjectsState.initialized;\r\n    if (hasObjects || fromInitializedState) {\r\n      // should always start a new sync sequence if we're in the initialized state, no matter the HAS_OBJECTS flag value.\r\n      // this guarantees we emit both \"syncing\" -> \"synced\" events in that order.\r\n      this._startNewSync();\r\n    }\r\n\r\n    if (!hasObjects) {\r\n      // if no HAS_OBJECTS flag received on attach, we can end sync sequence immediately and treat it as no objects on a channel.\r\n      // reset the objects pool to its initial state, and emit update events so subscribers to root object get notified about changes.\r\n      this._objectsPool.resetToInitialPool(true);\r\n      this._syncObjectsDataPool.clear();\r\n      // defer the state change event until the next tick if we started a new sequence just now due to being in initialized state.\r\n      // this allows any event listeners to process the start of the new sequence event that was emitted earlier during this event loop.\r\n      this._endSync(fromInitializedState);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  actOnChannelState(state: API.ChannelState, hasObjects?: boolean): void {\r\n    switch (state) {\r\n      case 'attached':\r\n        this.onAttached(hasObjects);\r\n        break;\r\n\r\n      case 'detached':\r\n      case 'failed':\r\n        // do not emit data update events as the actual current state of Objects data is unknown when we're in these channel states\r\n        this._objectsPool.clearObjectsData(false);\r\n        this._syncObjectsDataPool.clear();\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  async publish(objectMessages: ObjectMessage[]): Promise<void> {\r\n    this._channel.throwIfUnpublishableState();\r\n\r\n    objectMessages.forEach((x) => ObjectMessage.encode(x, this._client));\r\n    const maxMessageSize = this._client.options.maxMessageSize;\r\n    const size = objectMessages.reduce((acc, msg) => acc + msg.getMessageSize(), 0);\r\n    if (size > maxMessageSize) {\r\n      throw new this._client.ErrorInfo(\r\n        `Maximum size of object messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n\r\n    return this._channel.sendState(objectMessages);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  throwIfInvalidAccessApiConfiguration(): void {\r\n    this._throwIfMissingChannelMode('object_subscribe');\r\n    this._throwIfInChannelState(['detached', 'failed']);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  throwIfInvalidWriteApiConfiguration(): void {\r\n    this._throwIfMissingChannelMode('object_publish');\r\n    this._throwIfInChannelState(['detached', 'failed', 'suspended']);\r\n    this._throwIfEchoMessagesDisabled();\r\n  }\r\n\r\n  private _startNewSync(syncId?: string, syncCursor?: string): void {\r\n    // need to discard all buffered object operation messages on new sync start\r\n    this._bufferedObjectOperations = [];\r\n    this._syncObjectsDataPool.clear();\r\n    this._currentSyncId = syncId;\r\n    this._currentSyncCursor = syncCursor;\r\n    this._stateChange(ObjectsState.syncing, false);\r\n  }\r\n\r\n  private _endSync(deferStateEvent: boolean): void {\r\n    this._applySync();\r\n    // should apply buffered object operations after we applied the sync.\r\n    // can use regular object messages application logic\r\n    this._applyObjectMessages(this._bufferedObjectOperations);\r\n\r\n    this._bufferedObjectOperations = [];\r\n    this._syncObjectsDataPool.clear();\r\n    this._currentSyncId = undefined;\r\n    this._currentSyncCursor = undefined;\r\n    this._stateChange(ObjectsState.synced, deferStateEvent);\r\n  }\r\n\r\n  private _parseSyncChannelSerial(syncChannelSerial: string | null | undefined): {\r\n    syncId: string | undefined;\r\n    syncCursor: string | undefined;\r\n  } {\r\n    let match: RegExpMatchArray | null;\r\n    let syncId: string | undefined = undefined;\r\n    let syncCursor: string | undefined = undefined;\r\n    if (syncChannelSerial && (match = syncChannelSerial.match(/^([\\w-]+):(.*)$/))) {\r\n      syncId = match[1];\r\n      syncCursor = match[2];\r\n    }\r\n\r\n    return {\r\n      syncId,\r\n      syncCursor,\r\n    };\r\n  }\r\n\r\n  private _applySync(): void {\r\n    if (this._syncObjectsDataPool.isEmpty()) {\r\n      return;\r\n    }\r\n\r\n    const receivedObjectIds = new Set<string>();\r\n    const existingObjectUpdates: { object: LiveObject; update: LiveObjectUpdate | LiveObjectUpdateNoop }[] = [];\r\n\r\n    for (const [objectId, entry] of this._syncObjectsDataPool.entries()) {\r\n      receivedObjectIds.add(objectId);\r\n      const existingObject = this._objectsPool.get(objectId);\r\n\r\n      if (existingObject) {\r\n        const update = existingObject.overrideWithObjectState(entry.objectState);\r\n        // store updates to call subscription callbacks for all of them once the sync sequence is completed.\r\n        // this will ensure that clients get notified about the changes only once everything has been applied.\r\n        existingObjectUpdates.push({ object: existingObject, update });\r\n        continue;\r\n      }\r\n\r\n      let newObject: LiveObject;\r\n      // assign to a variable so TS doesn't complain about 'never' type in the default case\r\n      const objectType = entry.objectType;\r\n      switch (objectType) {\r\n        case 'LiveCounter':\r\n          newObject = LiveCounter.fromObjectState(this, entry.objectState);\r\n          break;\r\n\r\n        case 'LiveMap':\r\n          newObject = LiveMap.fromObjectState(this, entry.objectState);\r\n          break;\r\n\r\n        default:\r\n          throw new this._client.ErrorInfo(`Unknown LiveObject type: ${objectType}`, 50000, 500);\r\n      }\r\n\r\n      this._objectsPool.set(objectId, newObject);\r\n    }\r\n\r\n    // need to remove LiveObject instances from the ObjectsPool for which objectIds were not received during the sync sequence\r\n    this._objectsPool.deleteExtraObjectIds([...receivedObjectIds]);\r\n\r\n    // call subscription callbacks for all updated existing objects\r\n    existingObjectUpdates.forEach(({ object, update }) => object.notifyUpdated(update));\r\n  }\r\n\r\n  private _applyObjectMessages(objectMessages: ObjectMessage[]): void {\r\n    for (const objectMessage of objectMessages) {\r\n      if (!objectMessage.operation) {\r\n        this._client.Logger.logAction(\r\n          this._client.logger,\r\n          this._client.Logger.LOG_MAJOR,\r\n          'Objects._applyObjectMessages()',\r\n          `object operation message is received without 'operation' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n        );\r\n        continue;\r\n      }\r\n\r\n      const objectOperation = objectMessage.operation;\r\n\r\n      switch (objectOperation.action) {\r\n        case ObjectOperationAction.MAP_CREATE:\r\n        case ObjectOperationAction.COUNTER_CREATE:\r\n        case ObjectOperationAction.MAP_SET:\r\n        case ObjectOperationAction.MAP_REMOVE:\r\n        case ObjectOperationAction.COUNTER_INC:\r\n        case ObjectOperationAction.OBJECT_DELETE:\r\n          // we can receive an op for an object id we don't have yet in the pool. instead of buffering such operations,\r\n          // we can create a zero-value object for the provided object id and apply the operation to that zero-value object.\r\n          // this also means that all objects are capable of applying the corresponding *_CREATE ops on themselves,\r\n          // since they need to be able to eventually initialize themselves from that *_CREATE op.\r\n          // so to simplify operations handling, we always try to create a zero-value object in the pool first,\r\n          // and then we can always apply the operation on the existing object in the pool.\r\n          this._objectsPool.createZeroValueObjectIfNotExists(objectOperation.objectId);\r\n          this._objectsPool.get(objectOperation.objectId)!.applyOperation(objectOperation, objectMessage);\r\n          break;\r\n\r\n        default:\r\n          this._client.Logger.logAction(\r\n            this._client.logger,\r\n            this._client.Logger.LOG_MAJOR,\r\n            'Objects._applyObjectMessages()',\r\n            `received unsupported action in object operation message: ${objectOperation.action}, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\r\n          );\r\n      }\r\n    }\r\n  }\r\n\r\n  private _throwIfMissingChannelMode(expectedMode: 'object_subscribe' | 'object_publish'): void {\r\n    // channel.modes is only populated on channel attachment, so use it only if it is set,\r\n    // otherwise as a best effort use user provided channel options\r\n    if (this._channel.modes != null && !this._channel.modes.includes(expectedMode)) {\r\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400);\r\n    }\r\n    if (!this._client.Utils.allToLowerCase(this._channel.channelOptions.modes ?? []).includes(expectedMode)) {\r\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400);\r\n    }\r\n  }\r\n\r\n  private _stateChange(state: ObjectsState, deferEvent: boolean): void {\r\n    if (this._state === state) {\r\n      return;\r\n    }\r\n\r\n    this._state = state;\r\n    const event = StateToEventsMap[state];\r\n    if (!event) {\r\n      return;\r\n    }\r\n\r\n    if (deferEvent) {\r\n      this._client.Platform.Config.nextTick(() => {\r\n        this._eventEmitterInternal.emit(event);\r\n        this._eventEmitterPublic.emit(event);\r\n      });\r\n    } else {\r\n      this._eventEmitterInternal.emit(event);\r\n      this._eventEmitterPublic.emit(event);\r\n    }\r\n  }\r\n\r\n  private _throwIfInChannelState(channelState: API.ChannelState[]): void {\r\n    if (channelState.includes(this._channel.state)) {\r\n      throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError());\r\n    }\r\n  }\r\n\r\n  private _throwIfEchoMessagesDisabled(): void {\r\n    if (this._channel.client.options.echoMessages === false) {\r\n      throw new this._channel.client.ErrorInfo(\r\n        `\"echoMessages\" client option must be enabled for this operation`,\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
